# -*- coding: utf-8 -*-
"""
/***************************************************************************
 WellMatchDockWidget
                                 A QGIS plugin
 Wyszukiwanie tożsamych otworów geologicznych w dwóch odrębnych bazach danych.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-11-09
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Dominik Szrek / PIG-PIB
        email                : dszr@pgi.gov.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import shutil
try:
    import pyarrow
except:
    import fastparquet
import numba
import pandas as pd
import numpy as np
import time as tm
import joblib

from datetime import datetime
from rapidfuzz import fuzz

from threading import Thread
from qgis.PyQt import uic
from qgis.PyQt.QtWidgets import QDockWidget, QMessageBox, QHBoxLayout
from qgis.PyQt.QtCore import Qt, pyqtSignal, QEvent, QModelIndex, QTimer
from qgis.core import QgsProject, QgsFeature, QgsGeometry, QgsPointXY, QgsRectangle
from qgis.utils import iface

from .classes import ADfModel, PDfModel, CustomButton, MultiStateButton, run_in_main_thread
from .maptools import MapToolManager
from .main import LayerManager, init_extent, check_files, df_load

UI_PATH = os.path.dirname(os.path.realpath(__file__)) + os.path.sep + 'ui' + os.path.sep
MODEL_PATH = os.path.dirname(os.path.realpath(__file__)) + os.path.sep + 'models' + os.path.sep
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'well_match_dockwidget_base.ui'))

class WellMatchDockWidget(QDockWidget, FORM_CLASS):  # type: ignore

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        super(WellMatchDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.closing = False
        self.proj = QgsProject.instance()
        self.proj.layersWillBeRemoved.connect(self.layers_removing)
        self.proj.legendLayersAdded.connect(self.layers_adding)
        self.app = iface.mainWindow()
        self.canvas = iface.mapCanvas()
        self.gui_mode = "init"
        self.b_mode = None
        self.btn_export_joint.setVisible(False)
        self.sel_change_void = False
        self.analizing = False
        self.btn_csv.setVisible(False)
        self.btn_cat_o.clicked.connect(lambda: setattr(self, 'cat', 'o'))
        self.btn_cat_a.clicked.connect(lambda: setattr(self, 'cat', 'a'))
        self.btn_cat_p.clicked.connect(lambda: setattr(self, 'cat', 'p'))
        self.btn_cat_u.clicked.connect(lambda: setattr(self, 'cat', 'u'))
        self.btn_cat_w.clicked.connect(lambda: setattr(self, 'cat', 'w'))
        self.btn_lvl.clicked.connect(self.level_up)
        self.btn_link_change.clicked.connect(self.link_change)
        self.btn_trash.clicked.connect(lambda: self.well_set('o'))
        self.btn_halt.clicked.connect(lambda: self.well_set('w'))
        self.btn_anal.clicked.connect(lambda: self.well_set('a'))
        self.btn_join.clicked.connect(lambda: self.well_set('p'))
        self.btn_export_joint.clicked.connect(self.export_joint)
        self.btn_csv.clicked.connect(self.manual_analize) #lambda: self.level_up(limit=100))
        self.btn_run.pressed.connect(self.analize_run)
        self.btn_b_sel = CustomButton(self.frm_loc, name="b_sel", size=36, checkable=True, tooltip="wybór otworu B z obszaru mapy")
        self.btn_c_add = CustomButton(self.frm_loc, name="c_add", size=36, checkable=True, tooltip="wybór współrzędnych XY z obszaru mapy")
        self.btn_c_del = CustomButton(self.frm_loc, name="c_del", size=36, checkable=False, visible=False, tooltip="usunięcie ustalonej na mapie lokalizacji otworu")
        self.btn_loc = MultiStateButton(self.frm_loc, name="xy", size=55, hsize=36, states_tooltips={0: "współrzędne XY są pobrane z otworu A", 1: "współrzędne XY są pobrane z otworu B", 2: "współrzędne XY wybrano z mapy", 3: "współrzędne XY nie zostały ustalone"}, disabled_states=[2])
        self.btn_mode = CustomButton(self.frm_b_options, name="mode", size=50, hsize=36, checkable=True, tooltip="tryb wyświetlania najlepiej dopasowanych otworów B", tooltip_on="tryb wyświetlania wszystkich otworów B z przestrzennego zakresu widoku mapy")
        b_sel_lay = QHBoxLayout()
        b_sel_lay.setContentsMargins(0, 0, 0, 0)
        b_sel_lay.setSpacing(0)
        b_sel_lay.addWidget(self.btn_b_sel)
        self.frm_b_sel.setLayout(b_sel_lay)
        self.frm_b_options.layout().addWidget(self.btn_mode)
        self.frm_loc.layout().addWidget(self.btn_loc)
        self.frm_loc.layout().addWidget(self.btn_c_add)
        self.frm_loc.layout().addWidget(self.btn_c_del)
        self.btn_b_sel.clicked.connect(lambda: self.mt.init("b_pick"))
        self.btn_loc.clicked.connect(self.loc_change)
        self.btn_c_add.clicked.connect(lambda: self.mt.init("c_loc_add"))
        self.btn_c_del.pressed.connect(self.loc_c_del)
        self.btn_mode.clicked.connect(self.mode_change)
        ss = f"background-image:url({UI_PATH}a1.png)"
        ss = ss.replace("\\", "/")
        self.icon_a.setStyleSheet(ss)
        self.icon_a1.setStyleSheet(ss)
        ss = f"background-image:url({UI_PATH}b1.png)"
        ss = ss.replace("\\", "/")
        self.icon_b.setStyleSheet(ss)
        self.icon_b1.setStyleSheet(ss)
        ss = f"background-image:url({UI_PATH}b2.png)"
        ss = ss.replace("\\", "/")
        self.icon_b2.setStyleSheet(ss)
        ss = f"background-image:url({UI_PATH}b3.png)"
        ss = ss.replace("\\", "/")
        self.icon_b3.setStyleSheet(ss)
        self.frm_solver_title.setVisible(False)
        self.frm_a1.setVisible(False)
        self.frm_b1.setVisible(False)
        self.frm_b2.setVisible(False)
        self.frm_b3.setVisible(False)

        # Parametry:
        self.a_idx = None
        self.a_x = float()
        self.a_y = float()
        self.a_z = None
        self.a_h = None
        self.a_r = None
        self.a_pnt = None
        self.b_pnt = False
        # self.pdf_sel = False
        self.a2_idx = None
        self.a_id = None
        self.cat = None
        self.sel_case = 0
        self.loc = 0
        self.b1_id = None
        self.a_changed = False

        # Dataframe'y:
        self.adf = pd.DataFrame()
        self.bdf = pd.DataFrame()
        self.bdf_1 = pd.DataFrame()
        self.abdf = pd.DataFrame()
        self.badf = pd.DataFrame()
        self.zdf = pd.DataFrame()
        self.hdf = pd.DataFrame()
        self.rdf = pd.DataFrame()
        self.pdf = pd.DataFrame()
        self.sel_pdf = pd.DataFrame()
        self.pck_pdf = pd.DataFrame()
        self.pck_adf = pd.DataFrame()
        self.other_pdf = pd.DataFrame()
        self.cdf = pd.DataFrame()
        self.adf_o = pd.DataFrame()
        self.adf_a = pd.DataFrame()
        self.adf_p = pd.DataFrame()
        self.adf_u = pd.DataFrame()
        self.adf_s = pd.DataFrame()

        self.abtmp = []
        self.batmp = []

        self._status = run_in_main_thread(self.status)
        self._pbar = run_in_main_thread(self.pbar.setValue)
        self._block = run_in_main_thread(self.block_frames)
        self._post_analize = run_in_main_thread(self.post_analize)
        self._print = run_in_main_thread(print)

        self.matched_mdl = None

        self.t_void = False  # Blokada stopera zmiany zasięgu mapcanvas'u
        self.extent = None  # Zasięg geoprzestrzenny aktualnego widoku mapy
        self.timer = None  # Obiekt stopera zmiany zasięgu mapcanvas'u

        self.app.installEventFilter(self)  # Nasłuchiwanie zmiany tytułu okna QGIS
        self.canvas.extentsChanged.connect(self.extent_changed)
        self.lyr = LayerManager(dlg=self)
        self.mt = MapToolManager(dlg=self, canvas=self.canvas)

    def eventFilter(self, obj, event):
        if obj is iface.mainWindow() and event.type() == QEvent.WindowTitleChange:
            # Zmiana tytułu okna QGIS:
            title = self.app.windowTitle()
            dashes = ['-', '—']  # W różnych wersjach QGIS występują inne dywizory w tytule
            _dash = ''
            for dash in dashes:
                if dash in title:
                    _dash = dash
                    break
            new_title = title.replace(f'{dash} QGIS', '| WellMatch')
            self.app.setWindowTitle(new_title)
        if obj is iface.mainWindow() and event.type() == QEvent.Close:
            # Zamknięcie QGIS'a:
            self.closing = True
            self.proj.clear()
            self.close()
        return super().eventFilter(obj, event)

    def _df_load(self):
        """Uruchomienie funkcji 'df_load' z .main z poziomu import_data_dialog."""
        df_load()

    def layers_removing(self, lyr_list):
        """Emitowany, jeśli warstwy mają być usunięte."""
        lyrs_required = []
        for lyr_id in lyr_list:
            lyr = self.proj.mapLayer(lyr_id)
            if lyr.name() in self.lyr.lyrs_names:
                # Zostanie usunięta warstwa niezbędna dla działania wtyczki:
                lyrs_required.append(lyr)
        if len(lyrs_required) > 0:
            m_text = "Została usunięta warstwa niezbędna do prawidłowego funkcjonowania wtyczki. WellMatch musi zostać wyłączony."
            self.project_corrupted(m_text)

    def layers_adding(self, lyr_list):
        """Emitowany, jeśli warstwy zostały dodane do legendy. W przypadku dodania warstwy o nazwie zarezerwowanej zostanie dodany suffix '_0'."""
        for lyr in lyr_list:
            if lyr.name() in self.lyr.lyrs_names:
                # Zmiana w nowej warstwie nazwy zarezerwowanej:
                lyr.setName(f"{lyr.name()}_0")

    def project_corrupted(self, m_text):
        """Wyświetla komunikat o awaryjnym wyłączeniu wtyczki. Wyłącza wtyczkę po jego zatwierdzeniu."""
        if not self.closing:
            QMessageBox.critical(self.app, "WellMatch", m_text)
            self.close()

    def extent_changed(self):
        """Zmiana zasięgu geoprzestrzennego widoku mapy."""
        if self.b_mode != "screen":
            return
        if self.t_void:
            # Wyjście z funkcji, jeśli stoper obecnie pracuje
            return
        self.t_void = True
        self.extent = self.canvas.extent()
        self.timer = QTimer()
        self.timer.setInterval(250)
        self.timer.timeout.connect(self.check_extent)
        self.timer.start()  # Odpalenie stopera

    def check_extent(self):
        """Sprawdzenie, czy zakres widoku mapy przestał się zmieniać."""
        if self.extent != self.canvas.extent():  # Zmienił się
            self.extent = self.canvas.extent()
        else:
            # Kasowanie stopera:
            if self.timer:
                self.timer.stop()
                self.timer = None
            self.t_void = False
            self.extent = self.canvas.extent()
            if self.b_mode == "screen":
                self.pdf_create_screen(zoom_void=True)

    def __setattr__(self, attr, val):
        """Przechwycenie zmiany atrybutu."""
        super().__setattr__(attr, val)
        if attr == "a_idx":
            self.frm_loc.setVisible(True) if val else self.frm_loc.setVisible(False)
        if attr == "gui_mode":
            self.frames_visibility()
            if val == "manual":
                self.b_mode = "top"
        if attr == "b_mode" and val:
            if val == "top":
                self.btn_lvl.setVisible(True)
                self.pdf_create_top(zoom_void=True)
            elif val == "screen":
                self.btn_lvl.setVisible(False)
        if attr == "loc":
            if val == 2:
                self.btn_loc.setEnabled(False)
                self.btn_c_add.setVisible(False)
                self.btn_c_del.setVisible(True)
                self.btn_loc.list_add(2)
                self.btn_loc.state = val
            else:
                self.btn_c_add.setVisible(True)
                self.btn_c_del.setVisible(False)
                self.btn_loc.setEnabled(True)
                self.btn_loc.list_del(2)
                self.btn_loc.state = val
        if attr == "sel_case":
            self.btn_link_change.setEnabled(False) if val == 0 else self.btn_link_change.setEnabled(True)
            if val == 0:
                if self.cat == "o":
                    self.btn_halt.setEnabled(True)
                    self.btn_anal.setEnabled(False)
                    self.btn_join.setEnabled(False)
                elif self.cat == "w":
                    self.btn_trash.setEnabled(True)
                    self.btn_anal.setEnabled(False)
                    self.btn_join.setEnabled(False)
            else:
                self.btn_halt.setEnabled(True)
                self.btn_anal.setEnabled(True)
                self.btn_join.setEnabled(True)
            if val == 1:  # Jest zaznaczony otwór B obecnie połączony z otworem A
                if len(self.sel_pdf) > 0:
                    b_x = self.sel_pdf['X'].values[0]
                    b_y = self.sel_pdf['Y'].values[0]
                    if np.isnan(b_x) or np.isnan(b_y):
                        self.btn_loc.list_del(1)
                    else:
                        self.a_pnt = np.array((self.a_x, self.a_y))
                        self.btn_loc.list_add(1)
                else:
                    if self.a_idx is not None:
                        self.btn_loc.list_del(1)
            self.btn_link_change.setText("SKASUJ POŁĄCZENIE") if val < 2 else self.btn_link_change.setText("USTAL POŁĄCZENIE")
            self.btn_link_change.setEnabled(False) if (self.cat == "o" or self.cat == "w") and val != 1 else self.btn_link_change.setEnabled(True)
        if attr == "cat" and val is not None:
            self.btn_link_change.setEnabled(False) if (val == "o" or val == "w") and self.sel_case != 1 else self.btn_link_change.setVisible(True)
            self.cat_change(val)
        if attr == "adf_o":
            self.btn_cat_o.setVisible(True) if len(self.adf_o) > 0 else self.btn_cat_o.setVisible(False)
            self.btn_cat_o.setText(f"Odrzucone ({len(self.adf_o)})")
        if attr == "adf_a":
            self.btn_cat_a.setVisible(True) if len(self.adf_a) > 0 else self.btn_cat_a.setVisible(False)
            self.btn_cat_a.setText(f"Analizowane ({len(self.adf_a)})")
        if attr == "adf_p":
            self.btn_cat_p.setVisible(True) if len(self.adf_p) > 0 else self.btn_cat_p.setVisible(False)
            self.btn_cat_p.setText(f"Połączone ({len(self.adf_p)})")
        if attr == "adf_u":
            self.btn_cat_u.setVisible(True) if len(self.adf_u) > 0 else self.btn_cat_u.setVisible(False)
            self.btn_cat_u.setText(f"Ulepszone ({len(self.adf_u)})")
        if attr == "adf_w":
            self.btn_cat_w.setVisible(True) if len(self.adf_w) > 0 else self.btn_cat_w.setVisible(False)
            self.btn_cat_w.setText(f"Wstrzymane ({len(self.adf_w)})")

# =============== KATEGORIE:
    def adf_unsel(self):
        """Brak aktywnego otworu A."""
        sel_tv = self.tv_adf.selectionModel()
        sel_tv.clearCurrentIndex()
        sel_tv.clearSelection()
        self.tv_adf.scrollToTop()

    def adf_sel_first(self):
        """Zaznacza pierwszy otwór na liście tv_adf."""
        index = self.tv_adf.model().index(0, 0)
        self.tv_adf.setCurrentIndex(index)
        self.tv_adf.scrollToTop()
        self.canvas_update()

    def adf_sel_active(self):
        """Zaznacza aktywny otwór na liście tv_adf."""
        try:
            a_id = self.adf[self.adf.index == self.a_idx]['ID'].values[0]
        except:
            return
        index = self.tv_adf.model().match(self.tv_adf.model().index(0, 0), Qt.DisplayRole, a_id)
        if index:
            self.tv_pdf.scrollTo(index[0])
            self.tv_adf.setCurrentIndex(index[0])
            self.canvas_update()

    def set_cat(self, _cat):
        """Inicjacja zmiany aktywnej kategorii."""
        self.cat = _cat

    def cat_btns_update(self, _btn):
        """Aktualizacja stanu przycisków kategorii."""
        btns = {self.btn_cat_o : self.adf_o,
                self.btn_cat_a : self.adf_a,
                self.btn_cat_p : self.adf_p,
                self.btn_cat_u : self.adf_u,
                self.btn_cat_w : self.adf_w}
        for btn, df in btns.items():
            if btn == _btn:
                if len(df) == 0:
                    # Ustawiona kategoria nie ma otworów - należy zmienić kategorię
                    self.set_first_cat(update=False)
                    return
                btn.setChecked(True)
                df = df.sort_values(by=['Me', 'Avg'], ascending=[False, False]).reset_index(drop=True)
                self.adf_mdl.setDataFrame(self.a_col(df))
                self.adf_sel_first()
                if _btn == self.btn_cat_o:
                    self.btn_trash.setVisible(False)
                    self.btn_halt.setVisible(True)
                    self.btn_halt.setText("WSTRZYMAJ   ►")
                    self.btn_anal.setVisible(True)
                    self.btn_anal.setText("ANALIZUJ   ►")
                    self.btn_join.setVisible(True)
                    self.btn_export_joint.setVisible(False)
                if _btn == self.btn_cat_w:
                    self.btn_trash.setVisible(True)
                    self.btn_halt.setVisible(False)
                    self.btn_anal.setVisible(True)
                    self.btn_anal.setText("ANALIZUJ   ►")
                    self.btn_join.setVisible(True)
                    self.btn_export_joint.setVisible(False)
                if _btn == self.btn_cat_a:
                    self.btn_trash.setVisible(True)
                    self.btn_halt.setVisible(True)
                    self.btn_halt.setText("◄   WSTRZYMAJ")
                    self.btn_anal.setVisible(False)
                    self.btn_join.setVisible(True)
                    self.btn_export_joint.setVisible(False)
                if _btn == self.btn_cat_p:
                    self.btn_trash.setVisible(True)
                    self.btn_halt.setVisible(True)
                    self.btn_halt.setText("◄   WSTRZYMAJ")
                    self.btn_anal.setVisible(True)
                    self.btn_anal.setText("◄   ANALIZUJ")
                    self.btn_join.setVisible(False)
                    self.btn_export_joint.setVisible(True)
            else:
                btn.setChecked(False)

    def cat_change(self, val):
        """Zmiana fitru kategorii."""
        btns = {'o' : self.btn_cat_o,
                'a' : self.btn_cat_a,
                'p' : self.btn_cat_p,
                'u' : self.btn_cat_u,
                'w' : self.btn_cat_w}
        self.cat_btns_update(btns[val])

    def cat_upd(self):
        """Aktualizacja dataframe'ów (self.adf_[cat]) po zmianie kategorii któregoś otworu w adf."""
        self.adf_o = self.adf[self.adf['cat'] == 'o'].reset_index(drop=True)
        self.adf_a = self.adf[self.adf['cat'] == 'a'].reset_index(drop=True)
        self.adf_p = self.adf[self.adf['cat'] == 'p'].reset_index(drop=True)
        self.adf_u = self.adf[self.adf['cat'] == 'u'].reset_index(drop=True)
        self.adf_w = self.adf[self.adf['cat'] == 'w'].reset_index(drop=True)
        self.save_adf()
        if self.cat:
            self.cat_change(self.cat)
        if self.a_idx is not None and not self.sel_change_void:
            self.adf_sel_active()

    def loc_c_add(self, point):
        """Dodaje lokalizację C."""
        iface.actionPan().trigger()
        if not point:
            return
        self.btn_loc.setChecked(False)
        self.btn_loc.setEnabled(False)
        self.btn_c_add.setChecked(False)
        self.btn_c_add.setVisible(False)
        self.btn_c_del.setVisible(True)
        self.cdf_update(x=point.x(), y=point.y())
        self.loc_change()
        self.canvas_update()

    def loc_c_del(self):
        """Usuwa lokalizację C."""
        self.btn_loc.setEnabled(True)
        self.btn_loc.setChecked(False)
        self.btn_c_add.setVisible(True)
        self.btn_c_del.setVisible(False)
        self.cdf_update()
        self.loc_change()
        self.canvas_update()

    def b_pick(self, feature):
        """Zaznacza wiersz w pdf z otworem B na podstawie podanego id."""
        iface.actionPan().trigger()
        if not feature:
            return
        b_id = feature['id']
        idx = self.tv_pdf.model().match(self.tv_pdf.model().index(0, 1), Qt.DisplayRole, b_id, flags=Qt.MatchExactly)
        if idx:
            self.tv_pdf.scrollTo(idx[0])
            self.tv_pdf.setCurrentIndex(idx[0])

    def cdf_update(self, x=None, y=None):
        """Aktualizuje w cdf lokalizację C dla aktualnego a_idx."""
        # Sprawdzenie, czy w cdf jest wiersz z a_idx:
        pck_cdf = self.cdf[self.cdf['a_idx'] == self.a_idx]
        if len(pck_cdf) == 0:  # Nie ma wpisu o takim a_idx
            if x:
                # Tryb dodawania wiersza:
                self.cdf = self.cdf.append({'a_idx': self.a_idx, 'X': x, 'Y': y}, ignore_index=True)
            else:
                # Tryb kasowania wiersza - nie ma czego kasować
                return
        else:
            if x:
                # Tryb aktualizacji wiersza:
                self.cdf.loc[pck_cdf.index, ['X']] = x
                self.cdf.loc[pck_cdf.index, ['Y']] = y
            else:
                # Tryb kasowania wiersza:
                self.cdf = self.cdf.drop(pck_cdf.index)
        self.save_cdf()

    def loc_establish(self):
        """Ustala jaki stan powinien mieć przycisk loc i w razie potrzeby zmienia wartość loc dla otworu A."""
        if not self.loc in self.btn_loc.states:
            self.btn_loc.state_reset()
            self.loc_change()
        else:
            self.btn_loc.state = self.loc

    def save_adf(self):
        """Zapisanie aktualnej wersji adf na dysku."""
        self.adf.to_parquet(f"{self.lab_path_content.text()}{os.path.sep}adf.parq", compression='gzip')
        print("adf_saved")

    def save_bdf(self):
        """Zapisanie aktualnej wersji bdf na dysku."""
        self.bdf.to_parquet(f"{self.lab_path_content.text()}{os.path.sep}bdf.parq", compression='gzip')
        print("bdf_saved")

    def save_cdf(self):
        """Zapisanie aktualnej wersji cdf na dysku."""
        self.cdf.to_parquet(f"{self.lab_path_content.text()}{os.path.sep}cdf.parq", compression='gzip')
        print("cdf_saved")

    def save_abdf(self, copy=None):
        """Zapisanie tymczasowej listy z połączeniami pomiędzy otworami do dataframe'u i jego zapis na dysku."""
        try:
            self.abdf = pd.concat([self.abdf, pd.DataFrame(self.abtmp, columns=['a_idx', 'b_idx', 'ab', 'ba'])]).reset_index(drop=True)
        except Exception as e:
            print(e)
            return
        self.abdf.to_parquet(f"{self.lab_path_content.text()}{os.path.sep}abdf.parq", compression='gzip')
        if copy:
            self.abdf.to_parquet(f"{self.lab_path_content.text()}{os.path.sep}abdf_{copy}.parq", compression='gzip')
        self.abtmp = []
        print("abdf_saved")

    def save_badf(self):
        """Zapisanie tymczasowej listy z połączeniami pomiędzy otworami do dataframe'u i jego zapis na dysku."""
        try:
            self.badf = pd.concat([self.badf, pd.DataFrame(self.batmp, columns=['b_idx', 'a_idx', 'ba'])]).reset_index(drop=True)
        except Exception as e:
            print(e)
            return
        self.badf.to_parquet(f"{self.lab_path_content.text()}{os.path.sep}badf.parq", compression='gzip')
        self.batmp = []
        print("badf_saved")

    def set_first_cat(self, update=True):
        """Ustawienie pierwszej niepustej kategorii."""
        if update:
            self.cat_upd()
        cats = {'a' : self.adf_a,
                'w' : self.adf_w,
                'p' : self.adf_p,
                'o' : self.adf_o,
                'u' : self.adf_u}
        for cat, df in cats.items():
            if len(df) > 0:
                self.cat = cat
                return

    def id_list_from_cat(self):
        """Zwraca listę otworów z aktualnej kategorii."""
        cats = {'o' : self.adf_o,
                'a' : self.adf_a,
                'p' : self.adf_p,
                'u' : self.adf_u,
                'w' : self.adf_w}
        for cat, df in cats.items():
            if cat == self.cat:
                df_cat = df
                break
        return df_cat['ID'].tolist()

    def analize_run(self):
        """Puszczenie lub przerwanie analizy."""
        if self.analizing:
            self.block_frames(False)
        else:
            self.block_frames(True)
            self.analize_thread()

    def analize_thread(self):
        """Uruchamia wątek z analizą."""
        t = Thread(target=self.automatic_analize)
        t.start()

    def automatic_analize(self):
        ts = tm.perf_counter()
        self.automatic_analize_1()
        self.automatic_analize_2()
        self.automatic_analize_rev()
        self.links_establish()
        te = tm.perf_counter()
        self._status(f"Czas działania wstępnej analizy: {tm.strftime('%H:%M:%S', tm.gmtime(te-ts))}")

    def project_reset(self, load=True):
        self.analizing = False
        self.abtmp = []
        self.batmp = []
        self.a_idx = None
        self.a_id = None
        self.a_x = float()
        self.a_y = float()
        self.a_z = None
        self.a_h = None
        self.a_r = None
        self.a_pnt = None
        self.pdf_sel = False
        self.a2_idx = None
        self.b1_id = None
        self.adf = pd.DataFrame()
        self.bdf = pd.DataFrame()
        self.bdf_1 = pd.DataFrame()
        self.abdf = pd.DataFrame()
        self.badf = pd.DataFrame()
        self.zdf = pd.DataFrame()
        self.hdf = pd.DataFrame()
        self.rdf = pd.DataFrame()
        self.pdf = pd.DataFrame()
        self.sel_pdf = pd.DataFrame()
        self.pck_pdf = pd.DataFrame()
        self.pck_adf = pd.DataFrame()
        self.other_pdf = pd.DataFrame()
        self.cdf = pd.DataFrame()
        self.adf_o = pd.DataFrame()
        self.adf_a = pd.DataFrame()
        self.adf_p = pd.DataFrame()
        self.adf_u = pd.DataFrame()
        self.adf_s = pd.DataFrame()
        if load:
            df_load()

    def post_analize(self):
        """Usunięcie folderu 'data' wraz z zawartością po zakończeniu analizy wstępnej i ponowne załadowanie wszystkich dataframe'ów."""
        data_path = f"{self.lab_path_content.text()}{os.path.sep}data"
        shutil.rmtree(data_path, ignore_errors=True)
        self._block(False)
        self.project_reset()
        # a_path = f"{self.lab_path_content.text()}{os.path.sep}adf.parq"
        # adf = load_parq(a_path)
        # self.load_adf(adf)
        # b_path = f"{self.lab_path_content.text()}{os.path.sep}bdf.parq"
        # bdf = load_parq(b_path)
        # self.load_bdf(bdf)
        # ab_path = f"{self.lab_path_content.text()}{os.path.sep}abdf.parq"
        # abdf = load_parq(b_path)
        # self.load_bdf(bdf)
        # self.cat_upd()

    def matched_model_load(self):
        """Załadowanie modelu ml oceny jakości dopasowania."""
        self.matched_mdl = joblib.load(f"{MODEL_PATH}matched_rf.pkl")
        # df = pd.read_csv(r"C:\Users\dszr\!WM_model\adf_ml_210410.csv", error_bad_lines=False, index_col="a_idx", encoding="windows 1250", sep=";", decimal=',')
        # X = df.iloc[:,:-1]
        # y = df['matched'].copy()
        # model = RandomForestClassifier(n_estimators=300, oob_score=True, n_jobs=-1, random_state=42, max_features='auto', min_samples_leaf=1)
        # model.fit(X, y)
        # model_file = f"{MODEL_PATH}matched_rf.pkl"
        # joblib.dump(model, model_file)
        # self.matched_mdl = joblib.load(model_file)

    def a_dedupe(self):
        """Wyłączenie z fazy 1 otworów z bazy A, które mają takie same zestawy parametrów."""
        adf = self.adf[self.adf['bin'].isna()].copy()
        # Nadpisanie pustych wartości parametrów z, h i r w bazie A:
        adf[['Z', 'H']] = adf[['Z', 'H']].fillna(99999.)
        adf['ROK'] = adf['ROK'].fillna(99999)
        dupe = adf[adf.duplicated(subset=['Z', 'H', 'ROK'], keep=False)]
        dupe_idx = dupe.index.tolist()
        mask = self.adf.index.isin(dupe_idx)
        self.adf.loc[mask,['bin']] = -1

    def automatic_analize_1(self):
        """Automatyczna analiza otworów - faza 1."""
        ts = tm.perf_counter()
        # Wyłączenie z fazy 1 otworów, które mają te same zestawy parametrów:
        self.a_dedupe()
        # Wybranie otworów z bazy A, które jeszcze nie przeszły fazy 1 (w przypadku przerwania analizy):
        adf_cat = self.adf[self.adf['bin'].isna()]
        # Nadpisanie pustych wartości parametrów x, y, z, h i r w bazie B:
        bdf = self.bdf.copy()
        bdf[['X', 'Y']] = bdf[['X', 'Y']].fillna(-1)
        bdf[['Z', 'H']] = bdf[['Z', 'H']].fillna(99999.)
        bdf['ROK'] = bdf['ROK'].fillna(99999)
        i = 0
        a = len(adf_cat)
        # a = 1
        i_times = np.empty([0])
        self._pbar(0)
        for index in adf_cat.head(a).to_records():
            if not self.analizing:  # Wciśnięto przycisk STOP
                break
            tsi = tm.perf_counter()
            pass_flag = False
            i += 1
            # Parametry wybranego otworu z bazy A:
            a_idx = index[0]
            a_z = index[5]
            a_h = index[6]
            a_r = index[7]
            if not index[3] or index[4]:  # Otwór nie ma kompletu współrzędnych
                self.adf.iloc[a_idx, 9] = -1  # Oznaczenie, że otwór negatywnie przeszedł fazę 1 i jest gotowy do fazy 2
                pass_flag = True
            # Sprawdzenie, czy w bazie B są otwory z takimi samymi wartościami, co w otworze z bazy A:
            if not pass_flag:
                params = []
                chk_df = pd.DataFrame()
                if not pd.isna(a_z):
                    params.append(['Z', a_z])
                if not pd.isna(a_h):
                    params.append(['H', a_h])
                if not pd.isna(a_r):
                    params.append(['ROK', a_r])
                if len(params) == 2:  # Otwór z bazy A ma 2 niepuste parametry
                    chk_df = bdf[(bdf[params[0][0]] == params[0][1]) & (bdf[params[1][0]] == params[1][1])]
                elif len(params) == 3:  # Otwór z bazy A ma 3 niepuste parametry
                    chk_df = bdf[(bdf[params[0][0]] == params[0][1]) & (bdf[params[1][0]] == params[1][1]) & (bdf[params[2][0]] == params[2][1])]
                if len(chk_df) == 1:  # Tylko jeden otwór z bazy B ma te same wartości parametrów co otwór z bazy A (perfect match)
                    if chk_df.iloc[2, 0] == -1 or chk_df.iloc[3, 0] == -1:  # Otwór B nie ma kompletu współrzędnych
                        self.adf.iloc[a_idx, 9] = -1  # Oznaczenie, że otwór negatywnie przeszedł fazę 1 i jest gotowy do fazy 2
                        pass_flag = True
                    if not pass_flag:
                        self.adf.iloc[a_idx, 9] = 0  # Przydzielenie otworowi koszyka nr 0 (analiza 1 otworu z bazy B) i wykluczenie z fazy 2
                        a_params = [index[0], index[1], index[2], index[5], index[6], index[7], index[3], index[4]]
                        a_pnt = np.array((index[3], index[4])) if index[3] and index[4] else None
                        a_params.append(a_pnt)
                        self.analize_bin_0(a_params, chk_df)  # Analiza koszyka nr 0
                else:  # W bazie B nie ma otworów z pasującymi parametrami, albo jest ich więcej niż jeden
                    self.adf.iloc[a_idx, 9] = -1  # Oznaczenie, że otwór negatywnie przeszedł fazę 1 i jest gotowy do fazy 2
            tei = tm.perf_counter()
            i_time = tei - tsi
            i_times = np.append(i_times, [i_time])
            avg_time = np.mean(i_times)
            i_left = a - i
            time_left = i_left * avg_time
            self._pbar(round((i/a)*100 ,0))
            self._status(f"FAZA 1/4 [{i} / {a}]:\n\nczas iteracji:                  {round(i_time, 3)} sek\nśredni czas iteracji:         {round(avg_time, 3)} sek\nczas trwania fazy:          {tm.strftime('%H:%M:%S', tm.gmtime(tei-ts))}\nczas zakończenia fazy:    {tm.strftime('%H:%M:%S', tm.gmtime(time_left))}")
        self._pbar(0)
        self.save_adf()
        self.save_bdf()
        self.save_abdf(copy=1)
        # self._block(False)

    def automatic_analize_2(self):
        """Automatyczna analiza otworów - faza 2."""
        if not self.analizing:  # Wciśnięto przycisk STOP
            return
        ts = tm.perf_counter()
        adf_cat = self.adf[self.adf['bin'] == -1]
        self.bdf_1 = self.bdf[self.bdf['a_idx'].isna()].iloc[:, :-1].copy()
        i = 0
        a = len(adf_cat)
        # a = 1
        i_times = np.empty([0])
        self._pbar(0)
        for index in adf_cat.head(a).to_records():
            if not self.analizing:
                break
            tsi = tm.perf_counter()
            i += 1
            self.a_idx = index[0]
            self.a_n = index[2]
            self.a_z = index[5]
            self.a_h = index[6]
            self.a_r = index[7]
            self.a_x = index[3]
            self.a_y = index[4]
            self.a_pnt = np.array((self.a_x, self.a_y))
            self.initial_analize()
            self.adf.iloc[self.a_idx, 9] = 1  # Aktualizacja 'bin' w adf
            tei = tm.perf_counter()
            i_time = tei - tsi
            i_times = np.append(i_times, [i_time])
            avg_time = np.mean(i_times)
            i_left = a - i
            time_left = i_left * avg_time
            self._pbar(round((i/a)*100 ,0))
            self._status(f"FAZA 2/4 [{i} / {a}]:\n\nczas iteracji:                  {round(i_time, 3)} sek\nśredni czas iteracji:         {round(avg_time, 3)} sek\nczas trwania fazy:          {tm.strftime('%H:%M:%S', tm.gmtime(tei-ts))}\nczas zakończenia fazy:    {tm.strftime('%H:%M:%S', tm.gmtime(time_left))}")
        self._pbar(0)
        self.save_adf()
        self.save_abdf(copy=2)
        # self._block(False)

    def automatic_analize_rev(self):
        """Automatyczna wsteczna analiza otworów."""
        if not self.analizing:  # Wciśnięto przycisk STOP
            return
        ts = tm.perf_counter()
        # Stworzenie listy wszystkich otworów z bazy B, z którymi łączą się otwory z bazy A:
        if len(self.badf) == 0:
            b_idx = self.abdf['b_idx'].drop_duplicates().tolist()
        else:
            b1_idx = self.abdf['b_idx'].drop_duplicates().tolist()
            b2_idx = self.badf['b_idx'].drop_duplicates().tolist()
            t1 = tm.perf_counter()
            b_idx = list(set(b1_idx) - set(b2_idx))
            t2 = tm.perf_counter()
        mask = self.bdf.index.isin(b_idx)
        bdf_cat = self.bdf[self.bdf.index.isin(b_idx)]
        i = 0
        a = len(bdf_cat)
        i_times = np.empty([0])
        self._pbar(0)
        for index in bdf_cat.head(a).to_records():
            if not self.analizing:
                break
            tsi = tm.perf_counter()
            i += 1
            # Żeby nie mnożyć ilości zadeklarowanych zmiennych,
            # korzystamy ze zmiennych przeznaczonych dla bazy A,
            # ale dane są dla otworu z bazy B:
            self.a_idx = index[0]
            self.a_n = index[2]
            self.a_z = index[5]
            self.a_h = index[6]
            self.a_r = index[7]
            self.a_x = index[3]
            self.a_y = index[4]
            self.a_pnt = np.array((self.a_x, self.a_y))
            # Wyszukujemy wszystkie otwory z bazy A, które łączą się z aktualnie rozpatrywanym otworem z bazy B:
            mask = self.abdf[self.abdf['b_idx'] == index[0]]
            a_list = mask['a_idx'].tolist()
            if len(a_list) == 1:  # Rozpatrywany otwór z bazy B ma połączenie tylko z jednym otworem z bazy A
                self.batmp.append([index[0], a_list[0], 0])
            else:
                adf_cat = self.adf[self.adf.index.isin(a_list)]
                adf_cat = adf_cat.iloc[:,:7]
                # with pd.option_context('display.max_rows', None, 'display.max_columns', None): 
                #     print(adf_cat)
                self.reverse_analize(adf_cat)
            tei = tm.perf_counter()
            i_time = tei - tsi
            i_times = np.append(i_times, [i_time])
            avg_time = np.mean(i_times)
            i_left = a - i
            time_left = i_left * avg_time
            self._pbar(round((i/a)*100 ,0))
            self._status(f"FAZA 3/4 [{i} / {a}]:\n\nczas iteracji:                  {round(i_time, 3)} sek\nśredni czas iteracji:         {round(avg_time, 3)} sek\nczas trwania fazy:          {tm.strftime('%H:%M:%S', tm.gmtime(tei-ts))}\nczas zakończenia fazy:    {tm.strftime('%H:%M:%S', tm.gmtime(time_left))}")
        self._pbar(0)
        self.save_badf()
        # self._block(False)

    def links_establish(self):
        """Ustalenie połączeń między otworami."""
        if not self.analizing:  # Wciśnięto przycisk STOP
            self._block(False)
            return
        ts = tm.perf_counter()
        if not self.matched_mdl:
            # Wczytanie modelu ML:
            self.matched_model_load()
        # Sprawdzenie, czy do abdf zostały dodane wartości 'ba' z badf:
        ba_check = self.abdf[self.abdf['ba'].isna()]
        if len(ba_check) > 0:  # Należy dodać dane z badf do abdf
            self.abdf.drop(['ba'], axis=1, inplace=True)
            self.abdf['id'] = self.abdf['a_idx'].astype(str) + "_" + self.abdf['b_idx'].astype(str)
            self.abdf.set_index('id', inplace=True)
            self.badf['id'] = self.badf['a_idx'].astype(str) + "_" + self.badf['b_idx'].astype(str)
            self.badf.set_index('id', inplace=True)
            self.abdf = self.abdf.merge(self.badf['ba'], left_index=True, right_index=True)
            self.abdf = self.abdf.sort_values(['a_idx','ba']).reset_index(drop=True)
            self.save_abdf(copy=3)
        df = self.abdf.copy()
        # Utworzenie dataframe'u z ustalonymi połączeniami A do B (z czystej listy otworów A):
        a_list = df['a_idx'].unique()
        adf = pd.DataFrame({'a_idx': a_list[:], 'b_idx': np.nan})
        adf['b_idx'] = adf['b_idx'].astype('Int64')
        # Ustalenie bezpośrednich linków pomiędzy otworami A i B (otwory z bazy B występują tylko raz - tam, gdzie najprawdopodobniejsze poprawne połączenie):
        uabdf = self.main_links(df, adf)
        uabdf.to_parquet(f"{self.lab_path_content.text()}{os.path.sep}uabdf.parq", compression='gzip')
        # self._print(uabdf)
        # Przeprowadzenie analizy wyłącznie między zestawionymi otworami z baz A i B oraz zmiana ich kategorii na podstawie predykcji modelu maszynowego uczenia:
        i = 0
        a = len(uabdf)
        # a = 1
        i_times = np.empty([0])
        self._pbar(0)
        for index in uabdf.head(a).to_records():
            if not self.analizing:
                break
            tsi = tm.perf_counter()
            i += 1
            iadf = self.adf[self.adf.index == index[1]]
            if pd.isna(index[2]):
                # Do otworu A nie dopasowano żadnego otworu B - kategoria 'wstrzymane'
                self.adf.iloc[index[0], -13] = 'w'
                continue
            ibdf = self.bdf[self.bdf.index == index[2]]
            # Analiza ustalonego połączenia i przypisanie odpowiedniej kategorii:
            self.analize_picked(iadf, ibdf)
            tei = tm.perf_counter()
            i_time = tei - tsi
            i_times = np.append(i_times, [i_time])
            avg_time = np.mean(i_times)
            i_left = a - i
            time_left = i_left * avg_time
            self._pbar(round((i/a)*100 ,0))
            self._status(f"FAZA 4/4 [{i} / {a}]:\n\nczas iteracji:                  {round(i_time, 3)} sek\nśredni czas iteracji:         {round(avg_time, 3)} sek\nczas trwania fazy:          {tm.strftime('%H:%M:%S', tm.gmtime(tei-ts))}\nczas zakończenia fazy:    {tm.strftime('%H:%M:%S', tm.gmtime(time_left))}")
        self._pbar(0)
        self.save_adf()
        self.save_bdf()
        if self.analizing:
            # Usunięcie katalogu 'data' po zakończonej analizie wstępnej:
            self._post_analize()
        # self._block(False)

    def main_links(self, df, adf):
        """Zwraca dataframe z ustalonymi linkami między otworami A i B (bez powtórzeń otworów B)."""
        a_tot = len(adf)
        a = 0
        i_max = df['ab'].max()
        j_max = df['ba'].max()
        i = 0
        j = 0
        for i in range(i_max):
            for j in range(j_max):
                self._pbar(round((a/a_tot)*100 ,0))
                self._status(f"FAZA 4/4 [{a} / {a_tot}]:\n\nTworzenie macierzy połączeń ustalonych [i: {i} \ {i_max} | j: {j} \ {j_max}]")
                df_0 = df[(df['ab'] == i) & (df['ba'] == j)]
                a_0 = df_0['a_idx'].tolist()
                if len(a_0) == 0:
                    continue
                a += len(a_0)
                b_0 = df_0['b_idx'].tolist()
                df_0 = df_0.set_index('a_idx')
                adf.update(df_0)
                df_0 = df_0.reset_index()
                df = df.drop(df[(df['a_idx'].isin(a_0)) | df['b_idx'].isin(b_0)].index)
        return adf.reset_index(drop=True)

    def analize_bin_0(self, a, pdf):
        """Analiza otworu z koszyka 0 (pewniaki)."""
        # Obliczenie odległości od parametrów dla wybranego otworu z bazy B:
        pdf['m_dist'] = compute_dist(pdf.iloc[:,2:4], a[8]).astype('float32')
        pdf['z_dist'] = abs(pdf['Z'].astype(float) - a[3]).astype('float32')
        pdf['h_dist'] = abs(pdf['H'].astype(float).abs() - abs(a[4])).astype('float32')
        pdf['bin'] = 0
        pdf['bin'] = pdf['bin'].astype('category')
        pdf['r_dist'] = pdf['ROK'].abs() - a[5]
        pdf['r_dist'] = pd.to_numeric(pdf['r_dist'], errors='coerce').abs().astype(float)
        cols = pdf.columns.tolist()
        pdf = pdf.drop(np.r_[cols[:1], cols[2:7]], 1)
        # Ranking parametrów wybranego otworu:
        # Ranking m:
        pdf['m_rank'] = compute_m(pdf['m_dist'].to_frame())
        if pdf['m_rank'].values[0] < 0.85:  # Otwory są od siebie oddalone, na wszelki wypadek otwór z bazy A zostaje przeniesiony do następnej fazy
            self.adf.iloc[a[0], 9] = -1  # Oznaczenie, że otwór przeszedł fazę 1 i jest gotowy do fazy 2
            return
        # Ranking z, h i r:
        params = [['z', a[3], self.z_max], ['h', a[4], self.h_max], ['r', a[5], self.r_max]]
        for p in params:
            pdf[f"{p[0]}_rank"] = self.rank_param(pdf[f"{p[0]}_dist"], p[1], p[2])
        # Ranking n:
        if pd.isna(a[2]) or pd.isna(pdf['NAZWA'].values[0]):
            pdf['n_rank'] = 0.0
        elif not a[2] and not pdf['NAZWA'].values[0]:
            pdf['n_rank'] = 0.0
        else:
            pdf['n_rank'] = fuzz.token_sort_ratio(str(a[2]), str(pdf['NAZWA'].values[0])) / 100
        if pdf['n_rank'].values[0] < 0.7:  # Nazwy są znacznie różne, na wszelki wypadek otwór z bazy A zostaje przeniesiony do następnej fazy
            self.adf.iloc[a[0], 9] = -1  # Oznaczenie, że otwór przeszedł fazę 1 i jest gotowy do fazy 2
            return
        # Obliczenie średniej ze wszystkich parametrów (bez wartości 0):
        pdf['Avg'] = pdf[['m_rank', 'z_rank', 'h_rank', 'r_rank', 'n_rank']].replace(0.0, np.NaN).mean(axis=1)
        # Obliczenie mediany ze wszystkich parametrów:
        pdf['Me'] = pdf[['m_rank', 'z_rank', 'h_rank', 'r_rank', 'n_rank']].median(axis=1)
        if pdf['Me'].values[0] < 1.0:  # Wynik nie jest idealny, na wszelki wypadek otwór zostaje przeniesiony do następnej fazy
            self.adf.iloc[a[0], 9] = -1  # Oznaczenie, że otwór przeszedł fazę 1 i jest gotowy do fazy 2
            return
        # Zapisanie w bdf id otworu z bazy A (nie będzie już brany pod uwagę przy kolejnych fazach):
        self.bdf.iloc[pdf.index, -1] = a[0]
        # Zapisanie w adf kategorii otworu:
        self.adf.loc[a[0],['cat']] = 'p'
        # Utworzenie połączenia pomiędzy otworami:
        self.abtmp.append([a[0], pdf.index.values[0], 0, np.nan])
        # Usunięcie zbędnych kolumn:
        cols = pdf.columns.tolist()
        pdf = pdf.drop(np.r_[cols[:5], cols[6:12]], 1)
        # Zapisanie danych wybranego otworu na dysku:
        pdf.to_parquet(f"{self.lab_path_content.text()}{os.path.sep}data{os.path.sep}{a[0]}.parq", compression='gzip')

    def initial_analize(self):
        """Wstępna analiza otworu."""
        pdf = self.bdf_1  # Bierzemy pod uwagę otwory B, ktore pozostały po fazie 1
        # Obliczenie odległości od parametrów dla wszystkich otworów z B:
        if self.a_pnt is None:
            pdf['m_dist'] = np.nan
        else:
            pdf['m_dist'] = compute_dist(pdf.iloc[:,2:4], self.a_pnt).astype('float32')
        if self.a_z is None:
            pdf['z_dist'] = np.nan
        else:
            pdf['z_dist'] = abs(pdf['Z'].astype(float) - self.a_z).astype('float32')
        if self.a_h is None:
            pdf['h_dist'] = np.nan
        else:
            pdf['h_dist'] = abs(pdf['H'].astype(float).abs() - abs(self.a_h)).astype('float32')
        # Binning (koszykowanie) otworów po parametrach:
        params = ['m', 'z', 'h']
        for p in params:
            pdf[f"{p}_bin"] = self.param_binning(pdf, p)
        pdf['bin'] = pdf[['m_bin', 'z_bin', 'h_bin']].values.min(axis=1)
        pdf['bin'] = pdf['bin'].astype('category')
        bin_pdf = pd.concat(objs=[pdf['ID'], pdf['bin']], axis=1)
        cols = pdf.columns.tolist()
        pdf = pdf.drop(np.r_[cols[:1], cols[2:7], cols[10:16]], 1)
        # Ranking parametrów otworów z pierwszego koszyka:
        pdf_q = pdf.query('bin == 1')
        pdf_1 = self.rank_bin(pdf_q)
        # Selekcja najlepszych otworów z pierwszego koszyka:
        pdf_1 = self.estimate_bin_manual(pdf_1, add_cols=True)
        # Zapis połączeń między otworami:
        b = pdf_1.index.tolist()
        links = [(self.a_idx, element, index, np.nan) for index, element in enumerate(b)]
        for link in links:
            self.abtmp.append(link)
        # Usunięcie zbędnych kolumn:
        cols = pdf_1.columns.tolist()
        pdf_1 = pdf_1.drop(np.r_[cols[:4], cols[5:11]], 1)
        # Zapis danych do pliku:
        pdf_1.to_parquet(f"{self.lab_path_content.text()}{os.path.sep}data{os.path.sep}{self.a_idx}.parq", compression='gzip')

    def reverse_analize(self, pdf):
        """Odwortna analiza otworu (otwór B do połączonych otworów A)."""
        # Obliczenie odległości od parametrów dla wszystkich otworów A z pdf:
        if self.a_pnt is None:
            pdf['m_dist'] = np.nan
        else:
            pdf['m_dist'] = compute_dist(pdf.iloc[:,2:4], self.a_pnt).astype('float32')
        if self.a_z is None:
            pdf['z_dist'] = np.nan
        else:
            pdf['z_dist'] = abs(pdf['Z'].astype(float) - self.a_z).astype('float32')
        if self.a_h is None:
            pdf['h_dist'] = np.nan
        else:
            pdf['h_dist'] = abs(pdf['H'].astype(float).abs() - abs(self.a_h)).astype('float32')
        # Ranking parametrów otworów z bazy A:
        pdf_1 = self.rank_bin(pdf, rev=True)
        # Szacowanie jakości dopasowania otworów:
        pdf_1 = self.estimate_bin_manual(pdf_1, trim=False)
        # Zapis połączeń między otworami:
        b = pdf_1.index.tolist()
        links = [(self.a_idx, element, index) for index, element in enumerate(b)]
        for link in links:
            self.batmp.append(link)

    def analize_picked(self, adf, bdf):
        """Analiza otworu z bazy A z wybranym otworem z bazy B i aktualizacja danych w adf."""
        # Obliczenie odległości od parametrów dla wybranego otworu z bazy B:
        a_list = adf.values.tolist()[0]
        b_list = bdf.values.tolist()[0]
        m_void = False
        a_none = False
        b_none = False
        if pd.isna(a_list[2]) or pd.isna(a_list[3]):
            a_pnt = None
            a_none = True
            m_void = True
        else:
            a_pnt = np.array((a_list[2], a_list[3]))
        if pd.isna(b_list[2]) or pd.isna(b_list[3]):
            b_pnt = None
            b_none = True
            m_void = True
        else:
            b_pnt = np.array((b_list[2], b_list[3]))
        if m_void:
            adf['m_dist'] = np.nan
        else:
            adf['m_dist'] = round(np.linalg.norm(a_pnt - b_pnt))
        if pd.isna(a_list[4]) or pd.isna(b_list[4]):
            adf['z_dist'] = np.nan
        else:
            adf['z_dist'] = abs(float(a_list[4]) - float(b_list[4]))
        if pd.isna(a_list[5]) or pd.isna(b_list[5]):
            adf['h_dist'] = np.nan
        else:
            adf['h_dist'] = abs(float(abs(a_list[5])) - float(abs(b_list[5])))
        if pd.isna(a_list[6]) or pd.isna(b_list[6]):
            adf['r_dist'] = np.nan
        else:
            adf['r_dist'] = abs(a_list[6] - b_list[6])
            adf['r_dist'] = pd.to_numeric(adf['r_dist'], errors='coerce').abs().astype(float)
        # Ranking parametrów wybranego otworu:
        # Ranking m:
        if m_void:
            adf['m_rank'] = 0.0
        else:
            adf['m_rank'] = compute_m(adf['m_dist'].to_frame())
        # Ranking z, h i r:
        params = [['z', a_list[4], self.z_max], ['h', a_list[5], self.h_max], ['r', a_list[6], self.r_max]]
        for p in params:
            adf[f"{p[0]}_rank"] = 0.0 if not p[2] else self.rank_param(adf[f"{p[0]}_dist"], p[1], p[2])
        # Ranking n:
        if pd.isna(a_list[1]) or pd.isna(b_list[1]):
            adf['n_rank'] = 0.0
        elif not a_list[1] or not b_list[1]:
            adf['n_rank'] = 0.0
        else:
            adf['n_rank'] = fuzz.token_sort_ratio(str(a_list[1]), str(b_list[1])) / 100
        # Dodanie kolumn z pomiarów z fazy 2:
        a_parq = pd.read_parquet(f"{self.lab_path_content.text()}{os.path.sep}data{os.path.sep}{adf.index.values[0]}.parq")
        cols = ['Avg', 'Me', 'kNN', 'Avg1', 'Me1']
        a_parq = a_parq[a_parq.index == bdf.index.values[0]].reindex(columns=cols)
        a_parq = a_parq.rename_axis('b_idx').reset_index()
        a_parq['a_idx'] = adf.index.values[0]
        a_parq = a_parq.set_index('a_idx', drop=True)
        adf.update(a_parq)
        adf_vals = adf.values.tolist()[0]
        ml_vals = adf_vals[10:20]  # UWAGA: poprawić jeśli zmieni się struktura adf!
        # print(adf.columns.tolist())
        # print(adf.columns.tolist()[10:20])
        # print(ml_vals)
        pred = -1  # Zdefiniowanie wyniku predykcji
        if adf['cat'].values[0] == 'o':
            # Otwór nie został połączony w fazie 1 i musi zostać poddany predykcji ML:
            pred = self.matched_mdl.predict([ml_vals])
            if pred == 0:  # Predykcja kategorii 'wstrzymane'
                # Zapisanie w adf kategorii otworu:
                adf['cat'] = 'w'
                adf['b_idx'] = np.nan
            elif pred == 1:  # Predykcja kategorii 'analizowane'
                adf['cat'] = 'a'
            elif pred == 2:  # Predykcja kategorii 'połączone'
                adf['cat'] = 'p'
                # Ustalenie watrości loc:
                if not a_none:
                    adf['loc'] = 0
                elif a_none and not b_none:
                    adf['loc'] = 1
                elif a_none and b_none:
                    adf['loc'] = 3
        # Zapisanie w bdf id otworu z bazy A:
        if pred > 0:  # Blokada zapisu dla wstrzymanych otworów:
            act_bdf = self.bdf[self.bdf.index == bdf.index.values[0]]
            act_bdf['a_idx'] = adf.index.values[0]
            self.bdf.update(act_bdf)
        # Aktualizacja danych w adf:
        act_adf = self.adf[self.adf.index == int(adf.index.values[0])]
        act_adf.update(adf)
        self.adf.update(act_adf)

    def estimate_bin(self, tdf, add_cols=False, manual=False, trim=True, limit=10):
        """Oszacowanie najlepszych otworów z koszyka."""
        # Obliczenie średniej ze wszystkich parametrów (bez wartości 0):
        tdf['Avg'] = tdf[['m_rank', 'z_rank', 'h_rank', 'r_rank', 'n_rank']].replace(0.0, np.NaN).mean(axis=1)
        # Obliczenie mediany ze wszystkich parametrów:
        tdf['Me'] = tdf[['m_rank', 'z_rank', 'h_rank', 'r_rank', 'n_rank']].median(axis=1)
        # Oszacowanie optymalnej wartości k:
        k = int(np.ceil(np.sqrt(len(tdf))) // 2 * 2 + 1)
        # Wskazanie k najbliższych sąsiadów dla wszystkich parametrów:
        params = ['m', 'z', 'h', 'r', 'n']
        for p in params:
            # Nadanie wartości rankingowych od 0 do k:
            tdf[f"k_{p}"] = tdf.groupby(by=f"{p}_rank", sort=True).ngroup(ascending=False)
            mask = tdf[f"k_{p}"]
            tdf.loc[mask > k, f"k_{p}"] = k
        # Zsumowanie rankingów parametrów:
        tdf[f"kNN"] = tdf.iloc[:,-5:].sum(axis=1)
        if manual:  # Wykonywane tylko przy ręcznej analizie
            tdf = tdf.sort_values('kNN')
            return tdf
        # Usunięcie kolumn roboczych:
        cols = tdf.columns.tolist()
        tdf = tdf.drop(np.r_[cols[-6:-1]], 1)
        # Posortowanie otworów zaczynając od najlepiej dopasowanych:
        tdf = tdf.sort_values('kNN')
        if trim:
            # Usunięcie nadmiarowych otworów:
            tdf = tdf.head(limit)
        if add_cols:  # Wykonywane tylko przy analizie automatycznej w fazie 2
            # Dodanie kolumn z różnicami wyników średniej i mediany:
            tdf['Avg1'] = tdf['Avg'] - tdf['Avg'].shift(periods=-1, fill_value=1)
            tdf['Me1'] = tdf['Me'] - tdf['Me'].shift(periods=-1, fill_value=1)
        # with pd.option_context('display.max_rows', None, 'display.max_columns', None): 
        #     print(tdf)
        return tdf

    def estimate_bin_manual(self, tdf, add_cols=False, manual=False, trim=True, limit=10):
        """Oszacowanie najlepszych otworów z koszyka."""
        # Obliczenie średniej ze wszystkich parametrów (bez wartości 0):
        tdf['Avg'] = tdf[['m_rank', 'z_rank', 'h_rank', 'r_rank', 'n_rank']].replace(0.0, np.NaN).mean(axis=1)
        # Obliczenie mediany ze wszystkich parametrów:
        tdf['Me'] = tdf[['m_rank', 'z_rank', 'h_rank', 'r_rank', 'n_rank']].median(axis=1)
        # Oszacowanie optymalnej wartości k:
        k = int(np.ceil(np.sqrt(len(tdf))) // 2 * 2 + 1)
        # Wskazanie k najbliższych sąsiadów dla wszystkich parametrów:
        params = ['Avg', 'Me']
        for p in params:
            # Nadanie wartości rankingowych od 0 do k:
            tdf[f"k_{p}"] = tdf.groupby(by=f"{p}", sort=True).ngroup(ascending=False)
            mask = tdf[f"k_{p}"]
            tdf.loc[mask > k, f"k_{p}"] = k
        # Zsumowanie rankingów parametrów:
        tdf[f"kNN"] = tdf.iloc[:,-2:].sum(axis=1)
        if manual:  # Wykonywane tylko przy ręcznej analizie
            tdf = tdf.sort_values('kNN')
            return tdf
        # Usunięcie kolumn roboczych:
        cols = tdf.columns.tolist()
        tdf = tdf.drop(np.r_[cols[-3:-1]], 1)
        # Posortowanie otworów zaczynając od najlepiej dopasowanych:
        tdf = tdf.sort_values('kNN')
        if trim:
            # Usunięcie nadmiarowych otworów:
            tdf = tdf.head(limit)
        if add_cols:  # Wykonywane tylko przy analizie automatycznej w fazie 2
            # Dodanie kolumn z różnicami wyników średniej i mediany:
            tdf['Avg1'] = tdf['Avg'] - tdf['Avg'].shift(periods=-1, fill_value=1)
            tdf['Me1'] = tdf['Me'] - tdf['Me'].shift(periods=-1, fill_value=1)
        # with pd.option_context('display.max_rows', None, 'display.max_columns', None):
        #     print(tdf)
        return tdf

    def param_binning(self, pdf, param):
        """Klasyfikacja i podział otworów B w zależności od odległości danego parametru od aktywnego otworu z bazy A."""
        p_dist = f"{param}_dist"
        p_grp = f"{param}_grp"
        p_bin = f"{param}_bin"
        # Utworzenie serii z liczbami porządkowymi kolejnych unikalnych wartości odległości parametru:
        pdf[p_grp] = pdf.groupby(by=p_dist, sort=True).ngroup()
        p_max = pdf[p_grp].max()  # Wartość maksymalna odległości od parametru
        if pd.isna(p_max):
            # Cała kolumna złożona jest z pustych wartości, zwracamy jedną kategorię
            return pd.Series(1, index=pdf.index, dtype='category')
        mask = pd.isna(pdf[p_dist])  # Wyfiltrowanie NaN'ów w serii p_dist
        # Nadanie NaN'om ostatniej liczby porządkowej:
        if mask.sum() > 0:
            p_max += 1
            pdf.loc[mask,[p_grp]] = p_max
        pdf[p_grp] = pdf[p_grp].values + 1
        p_max += 2
        # Stworzenie granic przedziałów dla koszyków danych:
        bins = np.geomspace(1, p_max, 10, endpoint=True)
        labels = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        return pd.cut(pdf[p_grp], bins = bins, labels=labels, right=True, include_lowest=True)

    def rank_bin(self, tdf, rev=False):
        """Ranking parametrów dla wybranych (jeden koszyk) otworów z bazy B."""
        # Obliczenie odległości dla ROK:
        if self.a_r is None:
            tdf['r_dist'] = np.nan
        else:
            tdf['r_dist'] = self.r_dist(tdf.index, rev=rev)
        # Ranking m:
        if self.a_pnt is None:
            tdf['m_rank'] = 0.0
        else:
            tdf['m_rank'] = compute_m(tdf['m_dist'].to_frame())
        # Ranking z, h i r:
        params = [['z', self.a_z, self.z_max], ['h', self.a_h, self.h_max], ['r', self.a_r, self.r_max]]
        for p in params:
            tdf[f"{p[0]}_rank"] = 0.0 if not p[2] else self.rank_param(tdf[f"{p[0]}_dist"], p[1], p[2])
        # Ranking n:
        func = np.vectorize(self.rank_n)
        tdf['n_rank'] = func(tdf['NAZWA'])
        return tdf

    def rank_param(self, tdf, a_val, max):
        """Zwraca ranking wybranego parametru."""
        if a_val is None:
            return 0.0
        return compute_rank(tdf.to_frame(), max)

    def rank_n(self, tdf):
        """Ranking nazw (fuzzy matching)."""
        if pd.isna(self.a_n) or pd.isna(tdf):
            return 0.0
        if not self.a_n or not tdf:
            return 0.0
        return fuzz.token_sort_ratio(str(self.a_n), str(tdf)) / 100

    def r_dist(self, idx, rev):
        """Obliczenie odległości od parametru ROK między punktem z bazy A a punktami z bazy B (lub B do A, jeśli rev = True)."""
        tdf = self.adf.iloc[idx, 6] if rev else self.bdf.iloc[idx, 6]
        tdf['r_dist'] = tdf.abs() - self.a_r
        return pd.to_numeric(tdf['r_dist'], errors='coerce').abs().astype(float)

    def level_up(self):
        """Przejście otworu A na wyższy poziom - analiza względem wszystkich otworów B."""
        ts = tm.perf_counter()
        # Obliczenie we wszystkich otworach B parametrów odległości i rankingu względem wybranego otworu A:
        pdf = self.bdf.copy()
        pdf_1 = self.analize_selected(pdf)
        cur_lvl = int(self.adf.loc[self.a_idx, 'bin'])
        limit = 10 if cur_lvl < 2 else 100
        # Wybór 10 lub 100 najbardziej dopasowanych otworów B metodą K Najbliższych Sąsiadów:
        pdf_1 = self.estimate_bin_manual(pdf_1, limit=limit)
        # Skasowanie dotychczasowych połączeń między aktualnie wybranym otworem A i otworami B:
        mask = self.abdf[self.abdf['a_idx'] == self.a_idx]
        self.abdf = self.abdf.drop(mask.index)
        # Zapis nowych połączeń między otworami:
        b = pdf_1.index.tolist()
        links = [(self.a_idx, element, index, np.nan) for index, element in enumerate(b)]
        for link in links:
            self.abtmp.append(link)
        self.save_abdf()
        self.adf.iloc[self.a_idx, -12] = cur_lvl + 1  # Aktualizacja kolumny 'bin' w adf
        self.pdf_mdl.sort_reset()  # Wyłączenie sortowania po kolumnie
        self.tv_pdf.scrollToTop()
        self.cat_upd()
        te = tm.perf_counter()
        print(f"time: {round(te - ts, 2)} sek.")

    def analize_selected(self, pdf):
        """Analiza otworu po wybraniu z tv_adf."""
        # Obliczenie odległości od parametrów dla wybranego otworu z bazy B:
        if self.a_pnt is None:
            pdf['m_dist'] = np.nan
        else:
            pdf['m_dist'] = compute_dist(pdf.iloc[:,2:4], self.a_pnt).astype('float32')
        if self.a_z is None:
            pdf['z_dist'] = np.nan
        else:
            pdf['z_dist'] = abs(pdf['Z'].astype(float) - self.a_z).astype('float32')
        if self.a_h is None:
            pdf['h_dist'] = np.nan
        else:
            pdf['h_dist'] = abs(pdf['H'].astype(float).abs() - abs(self.a_h)).astype('float32')
        pdf_1 = self.rank_bin(pdf)
        return pdf_1

    def manual_analize(self):
        """Analiza manualna - zapis działania kNN do csv."""
        if self.a_idx is None:
            return
        pdf = self.bdf.copy()
        # Obliczenie odległości od parametrów dla wszystkich otworów z B:
        if self.a_pnt is None:
            pdf['m_dist'] = np.nan
        else:
            pdf['m_dist'] = compute_dist(pdf.iloc[:,2:4], self.a_pnt).astype('float32')
        if self.a_z is None:
            pdf['z_dist'] = np.nan
        else:
            pdf['z_dist'] = abs(pdf['Z'].astype(float) - self.a_z).astype('float32')
        if self.a_h is None:
            pdf['h_dist'] = np.nan
        else:
            pdf['h_dist'] = abs(pdf['H'].astype(float).abs() - abs(self.a_h)).astype('float32')
        # Binning (koszykowanie) otworów po parametrach:
        params = ['m', 'z', 'h']
        for p in params:
            pdf[f"{p}_bin"] = self.param_binning(pdf, p)
        pdf['bin'] = pdf[['m_bin', 'z_bin', 'h_bin']].values.min(axis=1)
        pdf['bin'] = pdf['bin'].astype('category')
        bin_pdf = pd.concat(objs=[pdf['ID'], pdf['bin']], axis=1)
        cols = pdf.columns.tolist()
        pdf = pdf.drop(np.r_[cols[:1], cols[2:7], cols[11:17]], 1)
        # Ranking parametrów otworów z pierwszego koszyka:
        pdf_q = pdf.query('bin == 1')
        pdf_1 = self.rank_bin(pdf_q)
        # Selekcja najlepszych otworów z pierwszego koszyka:
        pdf_1 = self.estimate_bin_manual(pdf_1, manual=True)
        pdf_1.to_csv(f"{self.lab_path_content.text()}{os.path.sep}{self.a_idx}.csv", index=False, encoding="cp1250", sep=";")

    def adf_sel_change(self):
        """Zmiana zaznaczenia wiersza w tableview z adf."""
        self.a_changed = True
        self.b1_id = None
        sel_tv = self.tv_adf.selectionModel()
        index = sel_tv.currentIndex()
        if index.row() == -1:
            # Brak zaznaczenia wiersza w tv_adf
            return
        if self.gui_mode != "manual":
            # Zablokowanie wykonywania funkcji przed wykonaniem analizy wstępnej
            return
        if self.sel_change_void:
            self.sel_change_void = False
            a_id = self.a_id
            self.a_id = None
        else:
            a_id = index.sibling(index.row(), 0).data()
        try:
            self.a_idx = self.adf.index[self.adf['ID'].astype(str) == str(a_id)][0]
        except Exception as err:
            self.a_idx = None
            return
        # Stworzenie ramki informacyjnej dla konsoli pythona:
        id_long = len(str(a_id)) if a_id else 4
        idx_long = len(str(self.a_idx)) if self.a_idx is not None else 4
        frame_long = id_long + 5 if id_long >= idx_long else idx_long + 5
        print(f"╔{'═' * (frame_long + 4)}╗")
        print(f"║ a_idx: {str(self.a_idx)}{' ' * (frame_long - (idx_long + 4))}║")
        print(f"║  a_id: {str(a_id)}{' ' * (frame_long - (id_long + 4))}║")
        print(f"╚{'═' * (frame_long + 4)}╝")
        # with pd.option_context('display.max_rows', None, 'display.max_columns', None): 
        #     print(self.adf.iloc[self.a_idx, :])
        self.a_n = self.adf.loc[self.a_idx, 'NAZWA']
        try:
            self.a_z = self.adf.loc[self.a_idx, 'Z']
        except:
            self.a_z = None
        finally:
            self.a_z = None if pd.isnull(self.a_z) else self.a_z
        try:
            self.a_h = self.adf.loc[self.a_idx, 'H']
        except:
            self.a_h = None
        finally:
            self.a_h = None if pd.isnull(self.a_h) else self.a_h
        try:
            self.a_r = self.adf.loc[self.a_idx, 'ROK']
        except:
            self.a_r = None
        finally:
            self.a_r = None if pd.isnull(self.a_r) else int(self.a_r)
        self.lab_a_id.setText(str(a_id))
        self.lab_a_name.setText(str(self.a_n))
        self.lab_a_z.setText("-") if self.a_z is None else self.lab_a_z.setText(self.float_format(self.a_z))
        self.lab_a_h.setText("-") if self.a_h is None else self.lab_a_h.setText(self.float_format(self.a_h))
        self.lab_a_r.setText("-") if self.a_r is None else self.lab_a_r.setText(str(self.a_r))
        self.a_x = self.adf[self.adf['ID'].astype(str) == str(a_id)]['X'].values[0]
        self.a_y = self.adf[self.adf['ID'].astype(str) == str(a_id)]['Y'].values[0]
        if np.isnan(self.a_x) or np.isnan(self.a_y):
            self.a_pnt = None
            self.btn_loc.list_del(0)
        else:
            self.a_pnt = np.array((self.a_x, self.a_y))
            self.btn_loc.list_add(0)
        self.frm_a1.setVisible(True)
        self.frm_solver_title.setVisible(True)
        self.frm_a_options.setVisible(True)
        self.frm_solver.setVisible(True)
        self.frm_b.setVisible(True)
        cur_lvl = int(self.adf.loc[self.a_idx, 'bin'])
        self.btn_lvl.setText("PEŁNA ANALIZA [10]") if cur_lvl <= 1 else self.btn_lvl.setText("PEŁNA ANALIZA [100]")
        self.btn_lvl.setEnabled(True) if cur_lvl < 3 else self.btn_lvl.setEnabled(False)
        self.loc = int(self.adf.loc[self.a_idx, 'loc'])
        self.pdf_create_screen() if self.b_mode == "screen" else self.pdf_create_top()

    def pdf_sel_change(self, zoom_void=False):
        """Zaznaczenie wiersza w tableview z pdf."""
        # Referencja do zaznaczonego wiersza w tv_pdf:
        sel_tv = self.tv_pdf.selectionModel()
        index = sel_tv.currentIndex()
        if index.row() != -1:
            self.b1_id = index.sibling(index.row(), 1).data()  # Zapamiętanie id nowego zaznaczonego otworu
        elif self.b1_id is not None:
            # Próba ponownego zaznaczenia wybranego otworu (potrzebne w trybie 'screen' po zmianie extent'u)
            idx = self.tv_pdf.model().match(self.tv_pdf.model().index(0, 1), Qt.DisplayRole, self.b1_id)
            if idx:
                self.tv_pdf.scrollTo(idx[0])
                self.tv_pdf.setCurrentIndex(idx[0])
        elif index.row() == -1 and self.b1_id is None:  # Brak zaznaczonego wiersza w pdf_tv
            self.sel_case = 0
            self.other_pdf = self.pdf.copy()
            self.canvas_update(zoom_void=zoom_void)  # Aktualizacja warstw qgis
            return
        # Przekazanie do oddzielnego dataframe'u danych zaznaczonego otworu:
        mask = self.pdf['ID'].astype(str) == str(self.b1_id)
        self.sel_pdf = self.pdf[mask].reset_index(drop=True)
        # Przekazanie do oddzielnego dataframe'u danych wszystkich otworów z pdf z wyłączeniem zaznaczonego otworu:
        self.other_pdf = self.pdf[~mask].reset_index(drop=True)
        self.b1_update()  # Wczytanie danych zaznaczonego otworu do frame'u b1
        # Aktualizacja widoczności frame'ów z danymi otworowymi:
        self.frm_solver_title.setVisible(True)
        self.frm_a1.setVisible(True)
        self.frm_b1.setVisible(True)
        if self.sel_is_picked():
            # Zaznaczony w tv_pdf otwór jest zestawiony z aktualnie wybranym otworem A
            self.sel_case = 1
            self.pck_pdf = pd.DataFrame(columns=self.pck_pdf.columns)
            self.pck_adf = pd.DataFrame(columns=self.pck_adf.columns)
            self.vl_solver.setContentsMargins(6, 6, 6, 12)
            self.vl_solver.setSpacing(6)
            self.frm_b2.setVisible(False)
            self.frm_b3.setVisible(False)
        else:
            # Przekazanie do oddzielnego dataframe'u danych otworu zestawionego z aktualnie wybranym otworem A:
            pdf = self.pdf.copy()
            pdf['a_idx'].fillna(-1, inplace=True)
            self.pck_pdf = pdf[pdf['a_idx'] == self.a_idx].reset_index(drop=True)
            if len(self.pck_pdf) > 0:
                # Usunięcie z other_pdf danych zestawionego otworu:
                b_idx = self.pck_pdf['b_idx'].values[0]
                mask = self.other_pdf['b_idx'] == b_idx
                self.other_pdf = self.other_pdf[~mask].reset_index(drop=True)
                self.b2_update()  # Wczytanie danych zestawionego otworu do frame'u b2
            if self.sel_is_taken():
                # Zaznaczony w tv_pdf otwór jest zestawiony z innym otworem A
                self.sel_case = 3
                self.a2_idx = self.sel_pdf['a_idx'][0]
                self.pck_adf = self.adf[self.adf.index == self.a2_idx].reset_index(drop=True)
                self.a2_update()
                self.frm_b2.setVisible(True) if len(self.pck_pdf) > 0 else self.frm_b2.setVisible(False)
                self.frm_b3.setVisible(True)
                self.vl_solver.setContentsMargins(6, 6, 6, 6)
                self.vl_solver.setSpacing(2)
            else:
                # Zaznaczony w tv_pdf otwór jest wolny (nie zestawiony z innym otworem A)
                self.sel_case = 2
                self.pck_adf = pd.DataFrame(columns=self.pck_adf.columns)
                self.frm_b2.setVisible(True) if len(self.pck_pdf) > 0 else self.frm_b2.setVisible(False)
                self.frm_b3.setVisible(False)
                self.vl_solver.setContentsMargins(6, 6, 6, 6)
                self.vl_solver.setSpacing(4)
        self.canvas_update(zoom_void=zoom_void)  # Aktualizacja warstw qgis

    def sel_is_picked(self):
        """Zwraca, czy otwór zaznaczony w tv_pdf jest zestawiony z aktualnie wybranym otworem A."""
        return False if self.sel_pdf['picked'].isna().any() else True

    def sel_is_taken(self):
        """Zwraca, czy otwór zaznaczony w tv_pdf jest zestawiony z jakimś otworem A."""
        return False if self.sel_pdf['a_idx'].isna().any() else True

    def b1_update(self):
        """Wyświetlenie frame'a b1 z danymi zaznaczonego otworu z bazy B."""
        try:
            b_name = self.sel_pdf.loc[0,'NAZWA']
        except Exception as error:
            self.status(f"Błąd wyszukiwania: {error}")
            return
        try:
            b_id = self.sel_pdf.loc[0,'ID']
        except:
            b_id = None
        finally:
            b_id = None if pd.isnull(b_id) else b_id
        try:
            b_z = self.sel_pdf.loc[0,'Z']
        except:
            b_z = None
        finally:
            b_z = None if pd.isnull(b_z) else b_z
        try:
            b_h = self.sel_pdf.loc[0,'H']
        except:
            b_h = None
        finally:
            b_h = None if pd.isnull(b_h) else b_h
        try:
            b_r = self.sel_pdf.loc[0,'ROK']
        except:
            b_r = None
        finally:
            b_r = None if pd.isnull(b_r) else b_r
        self.lab_b1_id.setText(str(b_id))
        self.lab_b1_name.setText(str(b_name))
        self.lab_b1_z.setText("-") if b_z is None else self.lab_b1_z.setText(self.float_format(b_z))
        self.lab_b1_h.setText("-") if b_h is None else self.lab_b1_h.setText(self.float_format(b_h))
        self.lab_b1_r.setText("-") if b_r is None else self.lab_b1_r.setText(str(b_r))

    def b2_update(self):
        """Wyświetlenie frame'a b2 z danymi zaznaczonego otworu z bazy B."""
        try:
            b_name = self.pck_pdf.loc[0,'NAZWA']
        except Exception as error:
            self.status(f"Błąd wyszukiwania: {error}")
            return
        try:
            b_id = self.pck_pdf.loc[0,'ID']
        except:
            b_id = None
        finally:
            b_id = None if pd.isnull(b_id) else b_id
        try:
            b_z = self.pck_pdf.loc[0,'Z']
        except:
            b_z = None
        finally:
            b_z = None if pd.isnull(b_z) else b_z
        try:
            b_h = self.pck_pdf.loc[0,'H']
        except:
            b_h = None
        finally:
            b_h = None if pd.isnull(b_h) else b_h
        try:
            b_r = self.pck_pdf.loc[0,'ROK']
        except:
            b_r = None
        finally:
            b_r = None if pd.isnull(b_r) else b_r
        self.lab_b2_id.setText(str(b_id))
        self.lab_b2_name.setText(str(b_name))
        self.lab_b2_z.setText("-") if b_z is None else self.lab_b2_z.setText(self.float_format(b_z))
        self.lab_b2_h.setText("-") if b_h is None else self.lab_b2_h.setText(self.float_format(b_h))
        self.lab_b2_r.setText("-") if b_r is None else self.lab_b2_r.setText(str(b_r))

    def a2_update(self):
        """Wyświetlenie frame'a A2 z danymi otworu z bazy A, który jest zestawiony aktualnie zaznaczonym otworem z tv_pdf."""
        try:
            b_name = self.pck_adf.loc[0,'NAZWA']
        except Exception as error:
            self.status(f"Błąd wyszukiwania: {error}")
            return
        try:
            b_id = self.pck_adf.loc[0,'ID']
        except:
            b_id = None
        finally:
            b_id = None if pd.isnull(b_id) else b_id
        try:
            b_z = self.pck_adf.loc[0,'Z']
        except:
            b_z = None
        finally:
            b_z = None if pd.isnull(b_z) else b_z
        try:
            b_h = self.pck_adf.loc[0,'H']
        except:
            b_h = None
        finally:
            b_h = None if pd.isnull(b_h) else b_h
        try:
            b_r = self.pck_adf.loc[0,'ROK'].astype(int)
        except:
            b_r = None
        finally:
            b_r = None if pd.isnull(b_r) else b_r
        self.lab_b_id.setText(str(b_id))
        self.lab_b_name.setText(str(b_name))
        self.lab_b_z.setText("-") if b_z is None else self.lab_b_z.setText(self.float_format(b_z))
        self.lab_b_h.setText("-") if b_h is None else self.lab_b_h.setText(self.float_format(b_h))
        self.lab_b_r.setText("-") if b_r is None else self.lab_b_r.setText(str(b_r))

    def pdf_create_top(self, zoom_void=False):
        """Tworzenie tymczasowego dataframe'a z otworami z bazy B połączonych z aktywnym otworem z bazy A."""
        if self.a_idx is None:
            return
        if len(self.abdf) == 0:
            return
        # Posprzątanie nieaktualnych danych:
        self.pdf = pd.DataFrame(columns=self.pdf.columns)
        self.sel_pdf = pd.DataFrame(columns=self.sel_pdf.columns)
        self.pck_pdf = pd.DataFrame(columns=self.pck_pdf.columns)
        self.pck_adf = pd.DataFrame(columns=self.pck_adf.columns)
        self.other_pdf = pd.DataFrame(columns=self.other_pdf.columns)
        self.pdf_mdl.sort_reset()  # Wyłączenie sortowania po kolumnie
        # Utworzenie listy otworów z bazy B, które mają linki z aktualnym otworem z bazy A:
        pdf_1 = self.abdf[self.abdf['a_idx'] == self.a_idx]
        pdf_1 = pdf_1.drop(columns=['a_idx'])
        pdf_1 = pdf_1.set_index('b_idx', drop=True)
        pdf_1.index.name = None
        # Pobranie parametrów wybranych otworów z bazy B:
        b_list = pdf_1.index.tolist()
        pdf_2 = self.bdf[self.bdf.index.isin(b_list)]
        # Przeprowadzenie analizy otworów, aby uzyskać wartości rankingowe
        # (przy automatycznej analizie ich nie zapisano z uwagi na oszczędność przestrzeni dyskowej):
        pdf_2 = self.analize_selected(pdf_2)
        # Obliczenie średniej ze wszystkich parametrów (bez wartości 0):
        pdf_2['Avg'] = pdf_2[['m_rank', 'z_rank', 'h_rank', 'r_rank', 'n_rank']].replace(0.0, np.NaN).mean(axis=1)
        # Obliczenie mediany ze wszystkich parametrów:
        pdf_2['Me'] = pdf_2[['m_rank', 'z_rank', 'h_rank', 'r_rank', 'n_rank']].median(axis=1)
        # Połączenie wszystkich powyższych danych we wspólny dataframe:
        self.pdf = pd.concat([pdf_2, pdf_1], axis=1)
        # Przesortowanie po parametrze 'ab':
        self.pdf = self.pdf.sort_values('ab').rename_axis('b_idx').reset_index()
        # Ustalenie, czy w otworach B znajduje się ustalone połączenie z otworem A:
        picked = self.pdf.copy()
        picked['a_idx'] = picked['a_idx'].fillna(-1)  # Uzupełnienie pustych wartości w kolumnie a_idx
        picked = picked[picked['a_idx'] == self.a_idx]  # Wybranie wiersza, który ma id otworu A
        self.btn_loc.list_add(1) if len(picked) > 0 else self.btn_loc.list_del(1)  # Dodanie lub skasowanie stanu guzika btn_loc dotyczącego lokalizacji wziętej z punktu B
        picked['picked'] = self.a_idx  # Stworzenie kolumny 'picked' z wartością 'a_idx'
        self.pdf['picked'] = np.nan  # Dodanie do pdf pustej kolumny 'picked'
        self.pdf['picked'].update(picked['picked'])  # Nadpisanie wiersza z pdf danymi z tymczasowego df 'picked'
        self.pdf['picked'] = self.pdf['picked'].astype('Int64')
        self.pdf_mdl.setDataFrame(self.p_col(self.pdf))
        self.picked_row_sel()
        self.pdf_sel_change(zoom_void=zoom_void)

    def pdf_create_screen(self, zoom_void=False):
        """Tworzenie tymczasowego dataframe'a z otworami z bazy B połączonych z aktywnym otworem z bazy A."""
        # extent = self.canvas.extent().scaled(0.9, self.canvas.extent().center())
        x1 = self.canvas.extent().xMinimum()
        x2 = self.canvas.extent().xMaximum()
        y1 = self.canvas.extent().yMinimum()
        y2 = self.canvas.extent().yMaximum()
        # Posprzątanie nieaktualnych danych:
        self.pdf = pd.DataFrame(columns=self.pdf.columns)
        self.sel_pdf = pd.DataFrame(columns=self.sel_pdf.columns)
        self.pck_pdf = pd.DataFrame(columns=self.pck_pdf.columns)
        self.pck_adf = pd.DataFrame(columns=self.pck_adf.columns)
        self.other_pdf = pd.DataFrame(columns=self.other_pdf.columns)
        # self.pdf_mdl.sort_reset()  # Wyłączenie sortowania po kolumnie
        # Utworzenie listy otworów z bazy B, które mają linki z aktualnym otworem z bazy A:
        pdf_1 = self.bdf[((self.bdf['X'] > x1) & (self.bdf['X'] < x2) & (self.bdf['Y'] > y1) & (self.bdf['Y'] < y2)) | (self.bdf['a_idx'].astype('str') == str(self.a_idx))]
        if len(pdf_1) == 0 and self.b1_id is None:
            # Zwraca pusty dataframe
            self.pdf_mdl.setDataFrame(self.p_col(self.pdf))
            return
        # Pobranie parametrów wybranych otworów z bazy B:
        b_list = pdf_1.index.tolist()
        if self.b1_id is not None:
            # Dodanie do listy zaznaczonego poprzednio otworu (może się znajdować poza extent'em)
            pdf_sel = self.bdf[self.bdf['ID'].astype('str') == str(self.b1_id)]
            if len(pdf_sel) > 0:
                sel_list = pdf_sel.index.tolist()
                b_list.extend(x for x in sel_list if x not in b_list)
        pdf_2 = self.bdf[self.bdf.index.isin(b_list)]
        # Przeprowadzenie analizy otworów, aby uzyskać wartości rankingowe
        # (przy automatycznej analizie ich nie zapisano z uwagi na oszczędność przestrzeni dyskowej):
        pdf_2 = self.analize_selected(pdf_2)
        # Obliczenie średniej ze wszystkich parametrów (bez wartości 0):
        pdf_2['Avg'] = pdf_2[['m_rank', 'z_rank', 'h_rank', 'r_rank', 'n_rank']].replace(0.0, np.NaN).mean(axis=1)
        # Obliczenie mediany ze wszystkich parametrów:
        pdf_2['Me'] = pdf_2[['m_rank', 'z_rank', 'h_rank', 'r_rank', 'n_rank']].median(axis=1)
        # Połączenie wszystkich powyższych danych we wspólny dataframe:
        pdf_2['ab'] = np.nan
        pdf_2['ba'] = np.nan
        self.pdf = pdf_2.copy() # pd.concat([pdf_2, pdf_1], axis=1)
        # Przesortowanie po parametrze 'm_rank':
        self.pdf = self.pdf.sort_values(by=['m_rank'], ascending=[False]).rename_axis('b_idx').reset_index()
        # Ustalenie, czy w otworach B znajduje się ustalone połączenie z otworem A:
        picked = self.pdf.copy()
        picked['a_idx'] = picked['a_idx'].fillna(-1)  # Uzupełnienie pustych wartości w kolumnie a_idx
        picked = picked[picked['a_idx'] == self.a_idx]  # Wybranie wiersza, który ma id otworu A
        picked['picked'] = self.a_idx  # Stworzenie kolumny 'picked' z wartością 'a_idx'
        self.pdf['picked'] = np.nan  # Dodanie do pdf pustej kolumny 'picked'
        self.pdf['picked'].update(picked['picked'])  # Nadpisanie wiersza z pdf danymi z tymczasowego df 'picked'
        self.pdf['picked'] = self.pdf['picked'].astype('Int64')
        self.pdf_mdl.setDataFrame(self.p_col(self.pdf))
        self.pdf_sel_change(zoom_void=zoom_void)
        self.picked_row_sel()

    def float_format(self, val):
        """Formatuje wartość float."""
        v = str(val).strip("0")
        dec = v.find(".")
        end = len(v) - 1
        dif = end - dec
        if dif == 0:
            return f"{'{:.1f}'.format(val)}"
        elif dif > 1:
            for i in range(dif, 1, -1):
                vi = str(f"{'{0:.{1}f}'.format(val, i)}").strip("0")
                dec = vi.find(".")
                end = len(vi) - 1
                dif = end - dec
                if dif <= 3:
                    return vi
        else:
            return v

    def well_set(self, cat):
        """Zmienia kategorię otworu."""
        if cat == "o" or cat == "w":
            # Otwór A zostanie odrzucony albo wstrzymany - należy zerwać połączenie z B, jeśli istnieje:
            result = self.remove_old_link_B()
            if not result:
                return
        elif cat == "a" or cat == "p":
            if self.sel_case == 2:
                # Usuwamy stare połączenie, jeśli istnieje:
                result = self.remove_old_link_B()
                if not result:
                    return
                # Ustalamy nowe połączenie
                result = self.make_link()
                if not result:
                    return
            elif self.sel_case == 3:
                # Usuwamy stare połączenie, jeśli istnieje:
                result = self.remove_old_link_B()
                if not result:
                    return
                result = self.remove_old_link_A()
                if not result:
                    return
                # Ustalamy nowe połączenie
                result = self.make_link()
                if not result:
                    return
        self.adf.loc[self.a_idx,'cat'] = cat  # Zmiana kategorii otworu A w adf
        self.save_adf()
        self.save_bdf()
        self.tv_adf.selectionModel().selectionChanged.disconnect(self.adf_sel_change)
        self.cat_upd()
        self.tv_adf.selectionModel().selectionChanged.connect(self.adf_sel_change)
        self.adf_sel_active()
        self.adf_sel_change()
        self.loc_establish()

    def remove_old_link_B(self):
        """Kasowanie aktualnego połączenia otworu A z B."""
        link_pdf = self.pdf[~self.pdf['picked'].isna()].reset_index(drop=True)  # Dataframe z ustalonym połączeniem (lub połączeniami, jeśli błąd)
        is_linked = True if len(link_pdf) > 0 else False
        if not is_linked:
            # Nie ma połączeń, które trzeba usunąć
            return True
        try:
            b_idx = int(link_pdf.iloc[0, 0])
        except:
            return False
        # Zrywamy ustalone połączenie:
        if self.sel_case == 1:
            m_text = f'<FONT COLOR="#000000">Czy chcesz zerwać połączenie otworu A:<br><FONT COLOR="#ff0000"><B>({self.lab_a_id.text()}) {self.lab_a_name.text()}</B></FONT><BR>z otworem B:<BR><FONT COLOR="#ff0000"><B>({link_pdf.loc[0, "ID"]}) {link_pdf.loc[0, "NAZWA"]}</B></FONT>?</FONT>'
        else:
            m_text = f'<FONT COLOR="#000000">Czy chcesz zerwać połączenie otworu A:<br><FONT COLOR="#ff0000"><B>({self.lab_a_id.text()}) {self.lab_a_name.text()}</B></FONT><BR>z otworem B:<BR><FONT COLOR="#0000ff"><B>({link_pdf.loc[0, "ID"]}) {link_pdf.loc[0, "NAZWA"]}</B></FONT>?</FONT>'
        reply = QMessageBox.question(None, "WellMatch", m_text, QMessageBox.Yes, QMessageBox.No)
        if reply == QMessageBox.No:
            return False
        self.bdf.iloc[b_idx,-1] = np.nan
        self.adf.iloc[self.a_idx, -1] = np.nan
        return True

    def remove_old_link_A(self):
        """Kasowanie starego połączenia w otworze B oraz kasowanie połączenia z innego otworu A i zmiana jego kategorii na 'w'."""
        try:
            old_b_idx = self.sel_pdf.iloc[0, 0]
        except:
            return False
        old_b_id = self.sel_pdf.iloc[0, 1]
        old_b_name = self.sel_pdf.iloc[0, 2]
        try:
            old_a_idx = self.sel_pdf.loc[0, 'a_idx']
        except:
            return False
        old_a_df = self.adf[self.adf.index == old_a_idx]
        old_a_id = old_a_df.iloc[0, 0]
        old_a_name = old_a_df.iloc[0, 1]
        m_text = f'<FONT COLOR="#000000">Zaznaczony otwór B:<br><FONT COLOR="#ff0000"><B>({old_b_id}) {old_b_name}</B></FONT><BR>jest już połączony z innym otworem A:<BR><FONT COLOR="#0000ff"><B>({old_a_id}) {old_a_name}</B></FONT>.<BR>Czy chcesz, aby otwór A:<BR><FONT COLOR="#0000ff"><B>({old_a_id}) {old_a_name}</B></FONT><BR>utracił połączenie z otworem B i został przeniesiony do kategorii "Wstrzymane"?</FONT>'
        reply = QMessageBox.question(None, "WellMatch", m_text, QMessageBox.Yes, QMessageBox.No)
        if reply == QMessageBox.No:
            return False
        # Kasowanie starego połączenia w otworze B:
        self.bdf.iloc[old_b_idx,-1] = np.nan
        self.adf.iloc[old_a_idx, -1] = np.nan
        self.adf.loc[old_a_idx,'cat'] = 'w'
        return True

    def make_link(self):
        """Połączenie otworu A z B."""
        pdf = self.sel_pdf.copy()
        try:
            b_idx = int(pdf.iloc[0, 0])
        except:
            return False
        self.bdf.iloc[b_idx,-1] = self.a_idx
        cols = pdf.columns.tolist()
        pdf = pdf.drop(np.r_[cols[1:13], cols[20:]], 1)
        pdf['a_idx'] = self.a_idx
        pdf = pdf.set_index('a_idx', drop=True)
        act_adf = self.adf[self.adf.index == self.a_idx]
        act_adf.update(pdf)
        self.adf.update(act_adf)
        self.save_adf()
        self.save_bdf()
        self.loc_establish()
        self.sel_change_void = True
        self.a_id = self.adf.loc[self.a_idx, 'ID']
        self.cat_upd()

    def export_joint(self):
        """Eksport tabeli z wynikami łączenia."""
        # Stworzenie tymczasowego dataframe'u z danymi otworów A:
        mask_a = self.adf['cat'] == 'p'
        exp_adf = self.adf.loc[mask_a,['ID', 'X', 'Y', 'loc']].copy()
        exp_adf.columns = ['ID_A', 'X_A', 'Y_A', 'loc']
        exp_adf = exp_adf.rename_axis('a_idx').reset_index()
        # Stworzenie tymczasowego dataframe'u z danymi otworów B:
        mask_b = ~self.bdf['a_idx'].isna()
        exp_bdf = self.bdf.loc[mask_b, ['ID', 'X', 'Y', 'a_idx']].copy()
        exp_bdf.columns = ['ID_B', 'X_B', 'Y_B', 'a_idx']
        # Stworzenie tymczasowego dataframe'u z danymi lokalizacji C:
        exp_cdf = self.cdf.copy()
        exp_cdf.columns = ['a_idx', 'X_C', 'Y_C']
        # Stworzenie dataframe'u ze złączenia powyższych:
        exp_df = exp_adf.merge(exp_bdf, on='a_idx', how='left')
        exp_df = exp_df.merge(exp_cdf, on='a_idx', how='left')
        exp_df['loc'] = pd.to_numeric(exp_df['loc'], downcast='integer')
        # Dodanie kolumn ze współrzędnymi i wypełnienie danymi w zależności od wartości 'loc':
        conditions = [exp_df['loc'] == 0, exp_df['loc'] == 1, exp_df['loc'] == 2, exp_df['loc'] == 3]
        choices_x = [exp_df['X_A'], exp_df['X_B'], exp_df['X_C'], np.nan]
        choices_y = [exp_df['Y_A'], exp_df['Y_B'], exp_df['Y_C'], np.nan]
        exp_df['X'] = np.select(conditions, choices_x, default=exp_df['X_A'])
        exp_df['Y'] = np.select(conditions, choices_y, default=exp_df['Y_A'])
        # Usunięcie niepotrzebnych kolumn:
        exp_df = exp_df.drop(columns=['X_A', 'Y_A', 'X_B', 'Y_B', 'X_C', 'Y_C', 'a_idx'])
        exp_df = exp_df[['ID_A', 'ID_B', 'X', 'Y', 'loc']]
        exp_df.columns = ['ID_A', 'ID_B', 'X', 'Y', '0=A 1=B 2=C, 3=?']
        # with pd.option_context('display.max_rows', None, 'display.max_columns', None): 
        #     print(exp_df)
        path = self.lab_path_content.text()
        path = path.replace("/", "\\")
        exp_path = f"{path}{os.path.sep}export"
        tmstmp = datetime.now().strftime("%Y-%m-%d [%H-%M-%S]")
        filename = f"export_{tmstmp}"
        if not os.path.isdir(exp_path):
            os.makedirs(exp_path)
        try:
            exp_df.to_csv(f"{exp_path}{os.path.sep}{filename}.csv", index=False, encoding="cp1250", sep=";", decimal=',')
        except:
            QMessageBox.critical(None, "Eksport wyników", f"Eksport danych do pliku {exp_path}{os.path.sep}{filename} nie powiódł się. Sprawdź, czy masz uprawnienia do zapisu w tym folderze.")
            return
        QMessageBox.information(None, "Eksport wyników", f"Dane o sparowanych otworach zostały wyeksportowane do pliku {exp_path}{os.path.sep}{filename}")

    def picked_row_sel(self):
        """Zaznacza wiersz z otworem zestawionym w tableview zbioru B."""
        if len(self.pdf) == 0:
            return
        if self.b1_id is not None:
            return
        tv_idx = self.pdf.index[~self.pdf['picked'].isna()].tolist()
        if len(tv_idx) == 0:
            self.pdf_sel = False
            index = QModelIndex()
            self.tv_pdf.scrollToTop()
            self.frm_b1.setVisible(False)
            self.frm_b2.setVisible(False)
            self.frm_b3.setVisible(False)
        else:
            self.pdf_sel = True
            index = self.tv_pdf.model().index(tv_idx[0], 0)
            self.tv_pdf.scrollTo(index)
        self.tv_pdf.setCurrentIndex(index)

    def copy_to_clipboard(self, tv, model):
        """Kopiuje zawartość komórki po dwukrotnym kliknięciu."""
        sel_tv = tv.selectionModel()
        index = sel_tv.currentIndex()
        item_txt = str(model.data(index, Qt.DisplayRole))
        cdf = pd.DataFrame([item_txt])
        cdf.to_clipboard(index=False, header=False)
        iface.messageBar().pushMessage("Skopiowano do schowka", item_txt)

    def load_adf(self, df):
        """Załadowanie adf po imporcie danych A."""
        if not 'cat' in df.columns:
            self.adf = self.add_a_cols(df)
            self.adf = self.acol_dtypes(self.adf)
            self.save_adf()
        else:
            self.adf = df
            self.adf = self.acol_dtypes(self.adf)
        tv_adf_widths = [60, 224, 30, 30, 30, 30, 30, 30, 30, 30]
        tv_adf_headers = ['ID','NAZWA', ' ', 'M', 'N', 'Z', 'Gł.', 'Rok', 'Śr.', 'Me.']
        self.adf_mdl = ADfModel(df=self.a_col(self.adf), tv=self.tv_adf, col_widths=tv_adf_widths, col_names=tv_adf_headers)
        self.tv_adf.selectionModel().selectionChanged.connect(self.adf_sel_change)
        self.tv_adf.doubleClicked.connect(lambda: self.copy_to_clipboard(self.tv_adf, self.adf_mdl))
        self.status(f"Do uzgodnienia wyznaczono {len(self.adf.index)} otworów.")
        if len(self.adf) > 0:
            self.set_first_cat()
        check_files()

    def load_bdf(self, df):
        """Załadowanie bdf po imporcie danych B."""
        if not 'a_idx' in df.columns:
            self.bdf = self.add_b_cols(df)
        else:
            self.bdf = df
        self.bdf = self.bcol_dtypes(self.bdf)
        self.save_bdf()
        check_files()
        self.init_pdf_tv()

    def init_pdf_tv(self):
        """Konfiguracja tableview pdf."""
        # Kolumny ukryte: pierwsza kolumna - 'picked', ostatnia kolumna - a_idx
        tv_pdf_widths = [1, 60, 241, 30, 30, 30, 30, 30, 30, 30, 1]
        tv_pdf_headers = ['', 'ID','NAZWA', 'M', 'N', 'Z', 'Gł.', 'Rok', 'Śr.', 'Me.', '.']
        self.pdf_mdl = PDfModel(df=pd.DataFrame(columns=tv_pdf_headers), tv=self.tv_pdf, col_widths=tv_pdf_widths, col_names=tv_pdf_headers)
        self.tv_pdf.selectionModel().selectionChanged.connect(lambda: self.pdf_sel_change(zoom_void=True))
        self.tv_pdf.doubleClicked.connect(lambda: self.copy_to_clipboard(self.tv_pdf, self.pdf_mdl))

    def calc_params_max(self):
        """Oblicza maksymalne odległości dla parametrów."""
        self.z_max = self.calc_max(self.adf['Z'], self.zdf['WARTOŚĆ'], False)
        self.h_max = self.calc_max(self.adf['H'], self.hdf['WARTOŚĆ'], True)
        self.r_max = self.calc_max(self.adf['ROK'], self.rdf['WARTOŚĆ'], True)

    def calc_max(self, adf, bdf, positives):
        """Oblicza maksymalną odległość dla podanego parametru."""
        if adf.isnull().all() or bdf.isnull().all():
            return None
        if positives:
            dists = [abs(abs(adf.min()) - abs(bdf.min())), abs(abs(adf.min()) - abs(bdf.max())), abs(abs(adf.max()) - abs(bdf.min())), abs(abs(adf.max()) - abs(bdf.max()))]
        else:
            dists = [abs(adf.min() - bdf.min()), abs(adf.min() - bdf.max()), abs(adf.max() - bdf.min()), abs(adf.max() - bdf.max())]
        return max(dists)

    def load_idf(self, dfs):
        """Załadowanie dataframe'ów indeksów po imporcie danych B."""
        for d in dfs:
            if d[0] == 'Z':
                self.zdf = d[1]
                self.zdf['WARTOŚĆ'] = pd.to_numeric(self.zdf['WARTOŚĆ'], downcast='float')
                self.zdf['ILOŚĆ'] = pd.to_numeric(self.zdf['ILOŚĆ'], downcast='integer')
            elif d[0] == 'H':
                self.hdf = d[1]
                self.hdf['WARTOŚĆ'] = pd.to_numeric(self.hdf['WARTOŚĆ'], downcast='float')
                self.hdf['ILOŚĆ'] = pd.to_numeric(self.hdf['ILOŚĆ'], downcast='integer')
            elif d[0] == 'ROK':
                self.rdf = d[1]
                self.rdf['WARTOŚĆ'] = pd.to_numeric(self.rdf['WARTOŚĆ'], downcast='integer')
                self.rdf['ILOŚĆ'] = pd.to_numeric(self.rdf['ILOŚĆ'], downcast='integer')

    def add_a_cols(self, df):
        """Dodanie dodatkowych kolumn do adf."""
        df = df.reindex(df.columns.tolist() + ['loc', 'cat', 'bin', 'm_rank', 'n_rank', 'z_rank', 'h_rank', 'r_rank', 'Avg', 'Me', 'kNN', 'Avg1', 'Me1', 'b_idx'], axis=1)
        return df

    def add_b_cols(self, df):
        """Dodanie dodatkowych kolumn do bdf."""
        df = df.reindex(df.columns.tolist() + ['a_idx'], axis=1)
        return df

    def mode_change(self):
        """Zmiana trybu wyświetlania otworów B ('top' - otwory najbardziej dopasowane wg analizy, 'screen' - wszystkie otwory z obrębu widoku mapy)."""
        self.b_mode = "screen" if self.btn_mode.isChecked() else "top"

    def loc_change(self):
        """Zmiana w adf wartości 'loc' dla otworu A (0 - prawidłowe są wpółrzędne XY z otworu A, 1 - prawidłowe są z otworu B, 2 - lokalizacja C, 3 - nie ustalono prawidłowej lokalizacji)."""
        if self.btn_loc.isEnabled():
            # Guzik jest włączony, co wyklucza self.loc == 2, należy zmienić self.loc na inną dostępną wartość
            if self.loc == 2:
                self.btn_loc.list_del(2)
                self.btn_loc.state_reset()
            self.loc = self.btn_loc.state
        else:
            # Guzik jest wyłaczony, powinien być ustalony self.loc = 2
            self.btn_loc.list_add(2)
            self.loc = 2
        mask = self.adf.index == self.a_idx
        self.adf.loc[mask,['loc']] = self.loc
        self.save_adf()

    def acol_dtypes(self, df):
        """Ustawienie kolumnom dataframe'a odpowiednich typów danych."""
        try:
            df['ID'] = df['ID'].convert_dtypes()
        except Exception as err:
            print(f"acol_dtypes[ID]: {err}")
        df['ID'] = df['ID'].astype(object)
        try:
            df['NAZWA'] = df['NAZWA'].convert_dtypes()
        except Exception as err:
            print(f"acol_dtypes[NAZWA]: {err}")
        df['NAZWA'] = df['NAZWA'].astype(object)
        df['X'] = df['X'].astype('float64')
        df['Y'] = df['Y'].astype('float64')
        df['Z'] = df['Z'].astype('float32')
        df['H'] = df['H'].astype('float32')
        df['ROK'] = df['ROK'].astype('Int64')
        df['loc'] = df['loc'].astype('category')
        df['loc'].cat.set_categories(range(0, 4), inplace=True)
        df['loc'] = df['loc'].fillna(0)
        df['cat'] = df['cat'].astype('category')
        df['cat'].cat.set_categories(['o', 'p', 'a', 'w', 'u'], inplace=True)
        df['cat'] = df['cat'].fillna('o')
        df['bin'] = df['bin'].astype('category')
        df['bin'].cat.set_categories(range(-1, 9), inplace=True)
        df['m_rank'] = df['m_rank'].astype('float32')
        df['n_rank'] = df['n_rank'].astype('float32')
        df['z_rank'] = df['z_rank'].astype('float32')
        df['h_rank'] = df['h_rank'].astype('float32')
        df['r_rank'] = df['r_rank'].astype('float32')
        df['Avg'] = df['Avg'].astype('float32')
        df['Me'] = df['Me'].astype('float32')
        df['kNN'] = df['kNN'].astype('Int64')
        df['Avg1'] = df['Avg1'].astype('float32')
        df['Me1'] = df['Me1'].astype('float32')
        df['b_idx'] = df['b_idx'].astype('Int64')
        return df

    def bcol_dtypes(self, df):
        """Ustawienie kolumnom dataframe'a odpowiednich typów danych."""
        try:
            df['ID'] = df['ID'].convert_dtypes()
        except Exception as err:
            print(f"acol_dtypes[ID]: {err}")
        df['ID'] = df['ID'].astype(object)
        try:
            df['NAZWA'] = df['NAZWA'].convert_dtypes()
        except Exception as err:
            print(f"acol_dtypes[NAZWA]: {err}")
        df['NAZWA'] = df['NAZWA'].astype(object)
        df['X'] = df['X'].astype('float64')
        df['Y'] = df['Y'].astype('float64')
        df['Z'] = df['Z'].astype('float32')
        df['H'] = df['H'].astype('float32')
        df['ROK'] = df['ROK'].astype('Int64')
        df['a_idx'] = df['a_idx'].astype('Int64')
        return df

    def status(self, txt):
        """Wyświetlenie tekstu w okienku statusu."""
        self.lab_status.setText(str(txt))

    def col_cut(self, df):
        """Zwraca dataframe bez kolumn X i Y."""
        return pd.concat(objs=[df.iloc[:,:2], df.iloc[:,4:7]], axis=1)

    def a_col(self, df):
        """Zwraca dataframe adf z kolumnami pasującymi do tv_adf."""
        return pd.concat(objs=[df.iloc[:,:2], df.iloc[:,-12:-4]], axis=1)

    def p_col(self, df):
        """Zwraca dataframe pdf z kolumnami pasującymi do tv_pdf."""
        return pd.concat(objs=[df.iloc[:,-1], df.iloc[:,1:3], df.iloc[:,13], df.iloc[:,17], df.iloc[:,14:17], df.iloc[:,18:20], df.iloc[:,8]], axis=1)

    def frames_visibility(self):
        """Ustawienie widoczności frame'ów w zależności od wartości 'gui_mode'."""
        vals = []
        frames = [self.frm_project, self.frm_import, self.frm_automatic, self.frm_manual]
        i = 0
        if self.gui_mode == 'init':
            vals = [True, False, False, False]
        elif self.gui_mode == 'new':
            vals = [True, True, False, False]
        elif self.gui_mode == 'automatic':
            vals = [True, False, True, False]
        elif self.gui_mode == 'manual':
            vals = [True, False, False, True]
        if len(vals) == 0:
            return
        for i in range(len(vals)):
            frames[i].setVisible(vals[i])

    def block_frames(self, val):
        """Wyłączenie ramek w trakcie analizy i włączenie po jej skończeniu/przerwaniu."""
        if val:
            self.btn_run.setText('Wstrzymaj analizę wstępną')
            self.analizing = True
            self.frm_project.setEnabled(False)
        else:
            self.btn_run.setText('Włącz analizę wstępną')
            self.analizing = False
            self.frm_project.setEnabled(True)

    def canvas_update(self, zoom_void=False):
        """Aktualizacja warstw projektowych."""
        self.a_1()
        self.a_2()
        self.c()
        self.b_1()
        self.b_2()
        self.b_inne()
        self.a1b1()
        self.a1b2()
        self.a2b1()
        if not zoom_void:
            self.canvas_zoom()
        else:
            iface.actionDraw().trigger()
            self.canvas.refresh()

    def a_1(self):
        """Umieszczenie na warstwie A_1 punktu wybranego otworu z bazy A. Jeśli otwór z bazy A nie jest wybrany - wyczyszczenie warstwy."""
        al = QgsProject.instance().mapLayersByName("A_1")[0]
        pr = al.dataProvider()
        pr.truncate()
        if self.a_idx is None or np.isnan(self.a_x) or np.isnan(self.a_y):
            return
        al.startEditing()
        ft = QgsFeature()
        attrs = [0, self.a_n]
        ft.setAttributes(attrs)
        ft.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(self.a_x, self.a_y)))
        pr.addFeatures([ft])
        al.endEditCommand()
        al.commitChanges()

    def a_2(self):
        """Umieszczenie na warstwie A_2 otworu z bazy A, który jest zestawiony z aktualnie zaznaczonym otworem z bazy B."""
        al = QgsProject.instance().mapLayersByName("A_2")[0]
        pr = al.dataProvider()
        pr.truncate()
        if len(self.pck_adf) == 0:
            return
        a_x = self.pck_adf['X'].values[0]
        a_y = self.pck_adf['Y'].values[0]
        if np.isnan(a_x) or np.isnan(a_y):
            return
        al.startEditing()
        for index in self.pck_adf.to_records():
            ft = QgsFeature()
            attrs = [0, str(index[2])]
            ft.setAttributes(attrs)
        ft.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(a_x, a_y)))
        pr.addFeatures([ft])
        al.endEditCommand()
        al.commitChanges()

    def c(self):
        """Umieszczenie na warstwie C lokalizacji otworu."""
        c = QgsProject.instance().mapLayersByName("C")[0]
        pr = c.dataProvider()
        pr.truncate()
        if self.loc != 2 or self.a_idx is None:
            # Otwór nie ma lokalizacji C
            c.triggerRepaint()
            return
        pck_cdf = self.cdf[self.cdf['a_idx'] == self.a_idx]
        if len(pck_cdf) == 0:
            # Otwór ma lokalizację C, ale nie ma współrzędnych tej lokalizacji
            QMessageBox.critical(None, "WellMatch", f"Otwór ma ustaloną lokalizację typu C, ale brak jest informacji o współrzędnych tej lokalizacji. Ustalono domyślną lokalizację.")
            self.btn_loc.setEnabled(True)
            self.loc_establish()
            c.triggerRepaint()
            return
        c_x = pck_cdf['X'].values[0]
        c_y = pck_cdf['Y'].values[0]
        c.startEditing()
        ft = QgsFeature()
        ft.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(c_x, c_y)))
        pr.addFeatures([ft])
        c.endEditCommand()
        c.commitChanges()

    def b_1(self):
        """Umieszczenie na warstwie B_1 wybranego otworu z bazy B (self.sel_pdf)."""
        bl = QgsProject.instance().mapLayersByName("B_1")[0]
        pr = bl.dataProvider()
        pr.truncate()
        if len(self.sel_pdf) == 0:
            return
        bl.startEditing()
        for index in self.sel_pdf.to_records():
            if np.isnan(index[4]) or np.isnan(index[5]):  # Brak współrzędnych punktu
                continue
            ft = QgsFeature()
            attrs = [str(index[2]), str(index[3])]
            ft.setAttributes(attrs)
            ft.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(index[4], index[5])))
            pr.addFeature(ft)
        bl.endEditCommand()
        bl.commitChanges()

    def b_2(self):
        """Umieszczenie na warstwie B_2 zestawionego otworu z bazy B (self.pck_pdf)."""
        bl = QgsProject.instance().mapLayersByName("B_2")[0]
        pr = bl.dataProvider()
        pr.truncate()
        if len(self.pck_pdf) == 0:
            return
        bl.startEditing()
        for index in self.pck_pdf.to_records():
            if np.isnan(index[4]) or np.isnan(index[5]):  # Brak współrzędnych punktu
                continue
            ft = QgsFeature()
            attrs = [str(index[2]), str(index[3])]
            ft.setAttributes(attrs)
            ft.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(index[4], index[5])))
            pr.addFeature(ft)
        bl.endEditCommand()
        bl.commitChanges()

    def b_inne(self):
        """Umieszczenie na warstwie B wybranych otworów z bazy B (self.pdf)."""
        bl = QgsProject.instance().mapLayersByName("B_INNE")[0]
        pr = bl.dataProvider()
        pr.truncate()
        if len(self.other_pdf) == 0:
            return
        bl.startEditing()
        for index in self.other_pdf.to_records():
            if np.isnan(index[4]) or np.isnan(index[5]):  # Brak współrzędnych punktu
                continue
            ft = QgsFeature()
            attrs = [str(index[2]), str(index[3])]
            ft.setAttributes(attrs)
            ft.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(index[4], index[5])))
            pr.addFeature(ft)
        bl.endEditCommand()
        bl.commitChanges()

    def a1b1(self):
        """Stworzenie linii łączącej wybrany otwór A z wybranym otworem B (self.sel_pdf)."""
        ll = QgsProject.instance().mapLayersByName("A1B1")[0]
        pr = ll.dataProvider()
        pr.truncate()
        if len(self.sel_pdf) == 0:
            return
        ll.startEditing()
        attrs= []
        for index in self.sel_pdf.to_records():
            if np.isnan(index[4]) or np.isnan(index[5]) or np.isnan(self.a_x) or np.isnan(self.a_y):  # Brak współrzędnych punktów
                continue
            ft = QgsFeature()
            attrs = [str(index[1]), int(round(float(index[10]),0))]
            ft.setAttributes(attrs)
            ft.setGeometry(QgsGeometry.fromPolylineXY([QgsPointXY(index[4], index[5]), QgsPointXY(self.a_x, self.a_y)]))
            pr.addFeature(ft)
        ll.endEditCommand()
        ll.commitChanges()

    def a1b2(self):
        """Stworzenie linii łączącej wybrany otwór A zestawiony z otworem z bazy B (self.pck_pdf)."""
        ll = QgsProject.instance().mapLayersByName("A1B2")[0]
        pr = ll.dataProvider()
        pr.truncate()
        if len(self.pck_pdf) == 0:
            return
        attrs= []
        a_x = self.a_x
        a_y = self.a_y
        b_x = self.pck_pdf['X'].values[0]
        b_y = self.pck_pdf['Y'].values[0]
        if np.isnan(a_x) or np.isnan(a_y) or np.isnan(b_x) or np.isnan(b_y):  # Brak współrzędnych punktów
            return
        a_pnt = np.array((a_x, a_y))
        b_pnt = np.array((b_x, b_y))
        dist = round(np.linalg.norm(a_pnt - b_pnt))
        ll.startEditing()
        ft = QgsFeature()
        for index in self.sel_pdf.to_records():
            attrs = [str(index[1]), int(round(float(dist),0))]
        ft.setAttributes(attrs)
        ft.setGeometry(QgsGeometry.fromPolylineXY([QgsPointXY(a_x, a_y), QgsPointXY(b_x, b_y)]))
        pr.addFeature(ft)
        ll.endEditCommand()
        ll.commitChanges()

    def a2b1(self):
        """Stworzenie linii łączącej otwór A (self.pck_adf) zestawiony z aktualnie wybranym otworem B (self.sel_pdf)."""
        ll = QgsProject.instance().mapLayersByName("A2B1")[0]
        pr = ll.dataProvider()
        pr.truncate()
        if len(self.pck_adf) == 0:
            return
        attrs= []
        a_x = self.sel_pdf['X'].values[0]
        a_y = self.sel_pdf['Y'].values[0]
        b_x = self.pck_adf['X'].values[0]
        b_y = self.pck_adf['Y'].values[0]
        if np.isnan(a_x) or np.isnan(a_y) or np.isnan(b_x) or np.isnan(b_y):  # Brak współrzędnych punktów
            return
        a_pnt = np.array((a_x, a_y))
        b_pnt = np.array((b_x, b_y))
        dist = round(np.linalg.norm(a_pnt - b_pnt))
        ll.startEditing()
        ft = QgsFeature()
        for index in self.sel_pdf.to_records():
            attrs = [str(index[1]), int(round(float(dist),0))]
        ft.setAttributes(attrs)
        ft.setGeometry(QgsGeometry.fromPolylineXY([QgsPointXY(a_x, a_y), QgsPointXY(b_x, b_y)]))
        pr.addFeature(ft)
        ll.endEditCommand()
        ll.commitChanges()

    def canvas_zoom(self):
        """Przybliżenie mapy do wyświetlonych obiektów."""
        if self.a_idx is None:  # Na mapie nic się nie wyświetla
            self.canvas.setExtent(init_extent())
            self.canvas.refresh()
            return
        if self.b_mode == "screen":
            if self.a_changed:
                # W trybie 'screen' zmieniono otwór A - zoom'ujemy na niego
                self.a_changed = False
                c_pnt = QgsPointXY(self.a_x, self.a_y)
                self.canvas.setCenter(c_pnt)
                self.canvas.zoomScale(10000)
                cs = self.canvas.scale()
                self.canvas.zoomScale(cs + (cs * 0.4))
            self.canvas.refresh()
            return
        l_x = []
        l_y = []
        a1 = QgsProject.instance().mapLayersByName("A_1")[0]
        a2 = QgsProject.instance().mapLayersByName("A_2")[0]
        b1 = QgsProject.instance().mapLayersByName("B_1")[0]
        b2 = QgsProject.instance().mapLayersByName("B_2")[0]
        c = QgsProject.instance().mapLayersByName("C")[0]
        lyrs = [a1, a2, b1, b2, c]
        for l in lyrs:
            if l.featureCount() == 1:
                f = l.getFeatures()
                feat_0 = QgsFeature()
                f.nextFeature(feat_0)
                pnt = QgsGeometry.asPoint(feat_0.geometry())
                xy = QgsPointXY(pnt)
                l_x.append(xy.x())
                l_y.append(xy.y())
        if len(l_x) == 0:  # Na mapie nic się nie wyświetla
            self.canvas.setExtent(init_extent())
            self.canvas.refresh()
            return
        p_x = [min(l_x), max(l_x)]
        p_y = [min(l_y), max(l_y)]
        for p in p_x:
            l_x.append(self.a_x + (self.a_x - p))
        for p in p_y:
            l_y.append(self.a_y + (self.a_y - p))
        bbox = QgsRectangle(min(l_x), min(l_y), max(l_x), max(l_y))
        self.canvas.setExtent(bbox)
        if self.canvas.scale() < 10000 or bbox.area() == 0.0:
            self.canvas.zoomScale(10000)
        cs = self.canvas.scale()
        self.canvas.zoomScale(cs + (cs * 0.4))
        self.canvas.refresh()

    def closeEvent(self, event):
        try:
            self.proj.layersWillBeRemoved.disconnect(self.layers_removing)
            self.proj.legendLayersAdded.disconnect(self.layers_adding)
        except Exception as err:
            print(f"closeEvent/self.proj.disconnect: {err}")
        self.proj = None
        self.canvas.extentsChanged.disconnect(self.extent_changed)
        try:
            self.canvas = None
        except Exception as err:
            print(f"closeEvent/self.canvas: {err}")
        try:
            self.lyr = None
        except Exception as err:
            print(f"closeEvent/self.lyr: {err}")
        try:
            self.mt = None
        except Exception as err:
            print(f"closeEvent/self.mt: {err}")
        try:
            self.app.removeEventFilter(self)
        except Exception as err:
            print(f"closeEvent/self.app.removeEventFilter: {err}")
        self.closingPlugin.emit()
        event.accept()

def list_diff(l1, l2):
    """Zwraca listę elementów l1, które nie występują w l2."""
    if not l1:
        return None
    if not l2:
        return l1
    return (list(set(l1)-set(l2)))

def compute_dist(df, a_pnt):
    result = apply_numba_dist(df['X'].to_numpy(), df['Y'].to_numpy(), a_pnt)
    return pd.Series(result, index=df.index, name='m_dist')

@numba.njit
def apply_numba_dist(x, y, a_pnt):
    n = len(x)
    result = np.empty(n, dtype='float32')
    for i in range(n):
        result[i] = numba_dist(x[i], y[i], a_pnt)
    return result

@numba.njit
def numba_dist(x, y, a_pnt):
    if np.isnan(x) or np.isnan(y):
        return np.nan
    b_pnt = np.array((x, y))
    return np.sqrt(np.sum(((a_pnt - b_pnt) ** 2)))

def compute_rank(df, max):
    result = apply_numba_rank(df.to_numpy(), max)
    return pd.Series(result, index=df.index)

@numba.njit
def apply_numba_rank(param, max):
    n = len(param)
    result = np.empty(n, dtype='float32')
    for i in range(n):
        result[i] = numba_rank(param[i][0], max)
    return result

@numba.njit
def numba_rank(val, max):
    if max == 0.0:
        return 0.0
    if np.isnan(val):
        return 0.0
    if val == 0.0:
        return 1.0
    elif val <= 2.0:
        return 1 - (val/10)
    elif val <= 4.0:
        return (8.1/9) - (val/20)
    elif val <= 8.0:
        return (7.2/9) - (val/40)
    elif val <= 16.0:
        return (6.3/9) - (val/80)
    elif val > 16.0:
        a = -0.5/(max-16.0)
        return a*(val - 16.0) + 0.5
        # a = 100
        # b = np.power(1/a, 1/max)
        # return (a * np.power(b, val))/100

def compute_m(df):
    result = apply_numba_m(df.to_numpy())
    return pd.Series(result, index=df.index)

@numba.njit
def apply_numba_m(param):
    n = len(param)
    result = np.empty(n, dtype='float32')
    for i in range(n):
        result[i] = numba_m(param[i][0])
    return result

@numba.njit
def numba_m(val):
    if np.isnan(val):
        return 0.0
    elif val == 0.0:
        return 1.0
    elif val <= 100.0:
        return 1 - (val/1000)
    elif val <= 1000.0:
        return (8.2/9) - (val/9000)
    elif val <= 10000.0:
        return (7.3/9) - (val/90000)
    elif val <= 100000.0:
        return (6.5/9) - (val/450000)
    elif val > 100000.0:
        return (5/9) - (val/1800000)
